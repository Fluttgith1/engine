// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#import <objc/message.h>

#import "flutter/shell/platform/darwin/macos/framework/Source/FlutterViewController_Internal.h"
#import "flutter/shell/platform/darwin/common/framework/Headers/FlutterCodecs.h"
#import "flutter/shell/platform/embedder/embedder.h"
#import "FlutterKeyboardPlugin.h"
#import "KeyCodeMap_internal.h"

static bool IsControlCharacter(NSUInteger length, NSString *label) {
  if (length > 1) {
    return false;
  }
  unichar codeUnit = [label characterAtIndex:0];
  return (codeUnit <= 0x1f && codeUnit >= 0x00) || (codeUnit >= 0x7f && codeUnit <= 0x9f);
}

static bool IsUnprintableKey(NSUInteger length, NSString *label) {
  if (length > 1) {
    return false;
  }
  unichar codeUnit = [label characterAtIndex:0];
  return codeUnit >= 0xF700 && codeUnit <= 0xF8FF;
}

static uint64_t KeyOfPlane(uint64_t baseKey, uint64_t plane) {
  return plane | (baseKey & kValueMask);
}

static uint64_t GetPhysicalKeyForEvent(NSEvent* event) {
  NSNumber* physicalKeyKey = [keyCodeToPhysicalKey objectForKey:@(event.keyCode)];
  if (physicalKeyKey == nil)
    return 0;
  return [physicalKeyKey intValue];
}

static uint64_t GetLogicalKeyForEvent(NSEvent* event, uint64_t physicalKey) {
  // Look to see if the keyCode is a printable number pad key, so that a
  // difference between regular keys (e.g. "=") and the number pad version (e.g.
  // the "=" on the number pad) can be determined.
  NSNumber* numPadKey = [keyCodeToNumpad objectForKey:@(event.keyCode)];
  if (numPadKey != nil)
    return [numPadKey intValue];

  NSString* keyLabel = event.charactersIgnoringModifiers;
  NSUInteger keyLabelLength = [keyLabel length];
  // If this key is printable, generate the LogicalKeyboardKey from its Unicode
  // value. Control keys such as ESC, CRTL, and SHIFT are not printable. HOME,
  // DEL, arrow keys, and function keys are considered modifier function keys,
  // which generate invalid Unicode scalar values.
  if (keyLabelLength != 0 &&
      !IsControlCharacter(keyLabelLength, keyLabel) &&
      !IsUnprintableKey(keyLabelLength, keyLabel)) {
    // Given that charactersIgnoringModifiers can contain a string of arbitrary
    // length, limit to a maximum of two Unicode scalar values. It is unlikely
    // that a keyboard would produce a code point bigger than 32 bits, but it is
    // still worth defending against this case.
    NSCAssert((keyLabelLength < 2),
        @"Unexpected long key label: |%@|. Please report this to Flutter.", keyLabel);

    uint64_t codeUnit = (uint64_t)[keyLabel characterAtIndex:0];
    if (keyLabelLength == 2) {
      uint64_t secondCode = (uint64_t)[keyLabel characterAtIndex:1];
      codeUnit = (codeUnit << 16) | secondCode;
    }
    return KeyOfPlane(codeUnit, kUnicodePlane);
  }

  // Control keys like "backspace" and movement keys like arrow keys don't have
  // a printable representation, but are present on the physical keyboard. Since
  // there is no logical keycode map for macOS (macOS uses the keycode to
  // reference physical keys), a LogicalKeyboardKey is created with the physical
  // key's HID usage and debugName. This avoids duplicating the physical key
  // map.
  if (physicalKey != 0) {
    return KeyOfPlane(physicalKey, kHidPlane);
  }

  // This is a non-printable key that is unrecognized, so a new code is minted
  // with the autogenerated bit set.
  return KeyOfPlane(event.keyCode, kMacosPlane | kAutogeneratedMask);
}

@interface FlutterKeyboardPlugin ()

/**
 * The FlutterViewController to manage input for.
 */
@property(nonatomic, weak) FlutterViewController* flutterViewController;

@end

@implementation FlutterKeyboardPlugin

- (instancetype)initWithViewController:(FlutterViewController*)viewController {
  self = [super init];
  if (self != nil) {
    _flutterViewController = viewController;
  }
  return self;
}

- (void)dispatchEvent:(NSEvent*)event {
  bool physicalDown = event.type == NSEventTypeKeyDown;
  uint64_t physicalKey = GetPhysicalKeyForEvent(event);
  uint64_t logicalKey = GetLogicalKeyForEvent(event, physicalKey);
  // Logical event
  FlutterLogicalKeyEvent logicalEvent = {
      .struct_size = sizeof(FlutterLogicalKeyEvent),
      .kind = physicalDown ? kFlutterKeyEventKindDown : kFlutterKeyEventKindUp,
      .key = logicalKey,
      .character_size = 0,
  };
  FlutterLogicalKeyEvent logical_events[] = {logicalEvent};
  const uint8_t logical_characters_data[] = {};
  uint8_t logical_event_count = 1;

  // Physical event
  // Timestamp in microseconds. The event.timestamp is in seconds with sub-ms precision.
  double timestamp = event.timestamp * 1000000.0;

  FlutterKeyEvent flutterEvent = {
      .struct_size = sizeof(FlutterKeyEvent),
      .logical_event_count = logical_event_count,
      .logical_events = logical_events,
      .logical_characters_data = logical_characters_data,
      .timestamp = timestamp,
      .kind = physicalDown ? kFlutterKeyEventKindDown : kFlutterKeyEventKindUp,
      .key = physicalKey,
  };
  [_flutterViewController dispatchFlutterKeyEvent:flutterEvent];
}

#pragma mark - Private


@end
