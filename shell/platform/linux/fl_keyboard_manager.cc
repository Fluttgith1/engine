// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "flutter/shell/platform/linux/fl_keyboard_manager.h"

#include <gtk/gtk.h>
#include <glib.h>

#include "flutter/shell/platform/linux/keyboard_map_private.h"

static constexpr uint64_t kLinuxKeyIdPlane = 0x00400000000;
static constexpr uint64_t kAutogeneratedMask = 0x10000000000;
static constexpr double kMicrosecondsPerMillisecond = 1000;

struct _FlKeyboardManager {
  FlLogicalKeyDatum logical_event_pool[kMaxConvertedLogicalKeyData];

  FlKeyDatum physical_event_pool[kMaxConvertedKeyData];

  // The owning Flutter view.
  FlView* view;

  GObject parent_instance;

  // Stores pressed keys, mapping their Flutter physical key to Flutter logical key.
  GHashTable* pressing_records;

  // Map XKB to Flutter's physical key code
  GHashTable* xkb_to_physical_key;

  // Map keyval to Flutter's logical key code
  GHashTable* keyval_to_logical_key;
};

G_DEFINE_TYPE(FlKeyboardManager, fl_keyboard_manager, G_TYPE_OBJECT)

static uint64_t event_to_physical_key(const GdkEventKey* event, GHashTable* table) {
  gpointer record = g_hash_table_lookup(table, GUINT_TO_POINTER(event->hardware_keycode));
  if (record != nullptr) {
    return GPOINTER_TO_UINT(record);
  }
  // Auto-generate key
  return kAutogeneratedMask | kLinuxKeyIdPlane | event->hardware_keycode;
}

static uint64_t event_to_logical_key(const GdkEventKey* event, GHashTable* table) {
  guint keyval = event->keyval;
  gpointer record = g_hash_table_lookup(table, GUINT_TO_POINTER(keyval));
  if (record != nullptr) {
    return GPOINTER_TO_UINT(record);
  }
  // ASCII // TODO
  if (keyval < 256) {
    return keyval;
  }
  // Auto-generate key
  return kAutogeneratedMask | kLinuxKeyIdPlane | keyval;
}

static uint64_t event_to_timestamp(const GdkEventKey* event) {
  return kMicrosecondsPerMillisecond * (double)event->time;
}

size_t fl_keyboard_manager_convert_key_event(FlKeyboardManager* self,
                                             const GdkEventKey* event,
                                             FlKeyDatum** result_physical,
                                             FlLogicalKeyDatum** result_logical) {
  uint64_t physical_key = event_to_physical_key(event, self->xkb_to_physical_key);
  uint64_t logical_key = event_to_logical_key(event, self->keyval_to_logical_key);

  FlLogicalKeyDatum* logical_datum = self->logical_event_pool + 0;
  result_logical[0] = logical_datum;
  logical_datum->kind = event->type == GDK_KEY_PRESS ? kFlKeyDataKindDown : kFlKeyDataKindUp;
  logical_datum->key = logical_key;
  logical_datum->character = "";
  logical_datum->repeated = false;

  FlKeyDatum* physical_datum = self->physical_event_pool + 0;
  result_physical[0] = physical_datum;
  physical_datum->logical_data_count = 1;
  physical_datum->timestamp = event_to_timestamp(event);
  physical_datum->active_locks = 0;
  physical_datum->kind = event->type == GDK_KEY_PRESS ? kFlKeyDataKindDown : kFlKeyDataKindUp;
  physical_datum->key = physical_key;
  physical_datum->repeated = false;

  return 1;
}

static void view_weak_notify_cb(gpointer user_data, GObject* object) {
  FlKeyboardManager* self = FL_KEYBOARD_MANAGER(object);
  self->view = nullptr;
}

static void fl_keyboard_manager_dispose(GObject* object) {
  FlKeyboardManager* self = FL_KEYBOARD_MANAGER(object);

  g_clear_pointer(&self->pressing_records, g_hash_table_unref);
  g_clear_pointer(&self->xkb_to_physical_key, g_hash_table_unref);
  g_clear_pointer(&self->keyval_to_logical_key, g_hash_table_unref);

  G_OBJECT_CLASS(fl_keyboard_manager_parent_class)->dispose(object);
}

static void fl_keyboard_manager_class_init(FlKeyboardManagerClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = fl_keyboard_manager_dispose;
}

static void fl_keyboard_manager_init(FlKeyboardManager* self) {
}

FlKeyboardManager* fl_keyboard_manager_new(FlView* view) {
  FlKeyboardManager* self = FL_KEYBOARD_MANAGER(
      g_object_new(fl_keyboard_manager_get_type(), nullptr));

  self->pressing_records = g_hash_table_new(g_direct_hash, g_direct_equal);
  self->xkb_to_physical_key = g_hash_table_new(g_direct_hash, g_direct_equal);
  initialize_xkb_to_physical_key(self->xkb_to_physical_key);
  self->keyval_to_logical_key = g_hash_table_new(g_direct_hash, g_direct_equal);
  initialize_gtk_keyval_to_logical_key(self->keyval_to_logical_key);

  self->view = view;
  g_object_weak_ref(G_OBJECT(view), view_weak_notify_cb, self);

  return self;
}
