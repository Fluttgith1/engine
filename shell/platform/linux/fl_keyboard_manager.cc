// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "flutter/shell/platform/linux/fl_engine_private.h"
#include "flutter/shell/platform/linux/fl_keyboard_manager.h"
#include "flutter/shell/platform/linux/keyboard_map_private.h"

static constexpr uint64_t kLinuxKeyIdPlane = 0x00400000000;
static constexpr uint64_t kAutogeneratedMask = 0x10000000000;
static constexpr double kMicrosecondsPerMillisecond = 1000;

struct _FlKeyEventPlugin {
  GObject parent_instance;

  // Stores pressed keys, mapping their Flutter physical key to Flutter logical key.
  GHashTable* pressing_records;

  // Map XKB to Flutter's physical key code
  GHashTable* xkb_to_physical_key;

  // Map keyval to Flutter's logical key code
  GHashTable* keyval_to_logical_key;
};

static uint64_t event_to_physical_key(GdkEventKey* event, GHashTable* table) {
  gpointer record = g_hash_table_lookup(table, GUINT_TO_POINTER(event->hardware_keycode));
  if (record != nullptr) {
    return GPOINTER_TO_UINT(record);
  }
  // Auto-generate key
  return kAutogeneratedMask | kLinuxKeyIdPlane | event->hardware_keycode;
}

static uint64_t event_to_logical_key(GdkEventKey* event) {
  guint keyval = event->keyval;
  gpointer record = g_hash_table_lookup(table, GUINT_TO_POINTER(keyval));
  if (record != nullptr) {
    return GPOINTER_TO_UINT(record);
  }
  // ASCII // TODO
  if (keyval < 256) {
    return keyval;
  }
  // Auto-generate key
  return kAutogeneratedMask | kLinuxKeyIdPlane | keyval;
}

static uint64_t event_to_timestamp(GdkEventKey* event) {
  return kMicrosecondsPerMillisecond * (double)event->time;
}

void fl_keyboard_manager_send_key_event(FlKeyboardManager* plugin, GdkEventKey* event) {
  uint64_t physical_key = event_to_physical_key(event, plugin->xkb_to_physical_key);
  uint64_t logical_key = event_to_logical_key(event, plugin->keyval_to_logical_key);

  FlutterLogicalKeyEvent logical_event = {};
  logical_event.struct_size = size(logical_event);
  logical_event.kind = event->type == GDK_KEY_PRESS ? kFlutterKeyEventKindDown : kFlutterKeyEventKindUp;
  logical_event.key = logical_key;
  logical_event.character_size = 0;
  logical_event.repeated = false;

  FlutterLogicalKeyEvent logical_events[] = {logical_event};

  FlutterKeyEvent physical_event = {};
  physical_event.struct_size = size(physical_event);
  physical_event.logical_event_count = 1;
  physical_event.logical_events = logical_events;
  physical_event.timestamp = event_to_timestamp(event);
  physical_event.active_locks = 0;
  physical_event.kind = event->type == GDK_KEY_PRESS ? kFlutterKeyEventKindDown : kFlutterKeyEventKindUp;
  physical_event.key = physical_key;
  physical_event.repeated = false;
}

static void fl_keyboard_manager_dispose(GObject* object) {
  FlKeyboardManager* self = FL_KEYBOARD_MANAGER(object);

  g_clear_pointer(&self->pressing_records, g_hash_table_unref);
  g_clear_pointer(&self->xkb_to_physical_key, g_hash_table_unref);
  g_clear_pointer(&self->keyval_to_logical_key, g_hash_table_unref);

  G_OBJECT_CLASS(fl_keyboard_manager_parent_class)->dispose(object);
}

static void fl_keyboard_manager_class_init(FlKeyboardManagerClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = fl_keyboard_manager_dispose;
}

FlKeyEventPlugin* fl_keyboard_manager_new() {
  FlKeybaordManager* self = FL_KEYBOARD_MANAGER(
      g_object_new(fl_keyboard_manager_get_type(), nullptr));

  self->pressing_records = g_hash_table_new(g_direct_hash, g_direct_equal);
  self->xkb_to_physical_key = g_hash_table_new(g_direct_hash, g_direct_equal);
  initialize_xkb_to_physical_key(self->xkb_to_physical_key);
  self->keyval_to_logical_key = g_hash_table_new(g_direct_hash, g_direct_equal);
  initialize_gtk_keyval_to_logical_key(self->keyval_to_logical_key);

  return self;
}
