// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "flutter/shell/platform/linux/fl_keyboard_manager.h"

#include <gtk/gtk.h>
#include <glib.h>

#include "flutter/shell/platform/linux/keyboard_map_private.h"

// Ensures that a uint64_t can be safely fit into a gpointer.
// 
// Flutter keyboard keys, values of uint64_t, are used by GHashTable by being
// reinterpreted as gpointers. This greatly simplifies the implementation
// (otherwise all keys and values needs allocation), but requires pointers to
// be at least 64-bit long.
//
// Reinterpreting integers as gpointers for GHashTable is officially supported
// by GTK, but natively it only supports 32-bit, probably due to crossplatform.
static_assert(sizeof(gpointer) >= sizeof(uint64_t));

static constexpr uint64_t kLinuxKeyIdPlane = 0x00400000000;
static constexpr uint64_t kAutogeneratedMask = 0x10000000000;
// // The `gdk_keyval_to_unicode` returns a guint32 character, which should not
// // exceed this length (including \0) after being converted to UTF-8.
// static constexpr size_t kCharacterPoolSize = 5;
static constexpr double kMicrosecondsPerMillisecond = 1000;

struct _FlKeyboardManager {
  gchar* character_to_free;

  // The owning Flutter view.
  FlView* view;

  GObject parent_instance;

  // Stores pressed keys, mapping their Flutter physical key to Flutter logical key.
  //
  // Both keys and values are malloc'd uint64. Responsible of freeing its keys,
  // but not its values.
  GHashTable* pressing_records;

  // Maps pressed logical keys to the times they are pressed; i.e. the times
  // they appear as values of `pressing_records`.
  //
  // Keys are malloc'd uint64_t, values are malloc'd int. Responsible of
  // freeing keys and values.
  GHashTable* pressed_logicals;

  // A static map from XKB to Flutter's physical key code
  GHashTable* xkb_to_physical_key;

  // A static map from GTK keyval to Flutter's logical key code
  GHashTable* keyval_to_logical_key;
};

G_DEFINE_TYPE(FlKeyboardManager, fl_keyboard_manager, G_TYPE_OBJECT)

static uint64_t event_to_physical_key(const GdkEventKey* event, GHashTable* table) {
  gpointer record = g_hash_table_lookup(table, GUINT_TO_POINTER(event->hardware_keycode));
  if (record != nullptr) {
    return GPOINTER_TO_UINT(record);
  }
  // Auto-generate key
  return kAutogeneratedMask | kLinuxKeyIdPlane | event->hardware_keycode;
}

static uint64_t event_to_logical_key(const GdkEventKey* event, GHashTable* table) {
  guint keyval = event->keyval;
  gpointer record = g_hash_table_lookup(table, GUINT_TO_POINTER(keyval));
  if (record != nullptr) {
    return GPOINTER_TO_UINT(record);
  }
  // ASCII // TODO
  if (keyval < 256) {
    return keyval;
  }
  // Auto-generate key
  return kAutogeneratedMask | kLinuxKeyIdPlane | keyval;
}

static uint64_t event_to_timestamp(const GdkEventKey* event) {
  return kMicrosecondsPerMillisecond * (double)event->time;
}

// Returns a newly accocated UTF-8 string from event->keyval that must be
// freed later with g_free().
static char* event_to_character(const GdkEventKey* event) {
  gunichar unicodeChar = gdk_keyval_to_unicode(event->keyval);
  glong items_written;
  gchar* result = g_ucs4_to_utf8(&unicodeChar, 1, NULL, &items_written, NULL);
  if (items_written == 0) {
    if (result != NULL)
      g_free(result);
    return nullptr;
  }
  return result;
}

static uint64_t gpointerToUint64(gpointer pointer) {
  return pointer == nullptr ? 0 : reinterpret_cast<uint64_t>(pointer);
}

static uint64_t gpointerToInt(gpointer pointer) {
  return pointer == nullptr ? 0 : GPOINTER_TO_INT(pointer);
}

static gpointer uint64ToGpointer(uint64_t number) {
  return reinterpret_cast<gpointer>(number);
}

// Return the logical key corresponding to the physical key.
//
// Returns 0 if not found.
static uint64_t pressed_logical_for_physical(GHashTable* pressing_records, uint64_t physical) {
  return gpointerToUint64(g_hash_table_lookup(pressing_records, uint64ToGpointer(physical)));
}

// Return the pressing count before the decrease.
//
// The logical pointer might be freed afterwards.
static int decrease_pressed_logical_count(GHashTable* pressed_logicals, uint64_t logical) {
  gpointer count_pointer = g_hash_table_lookup(pressed_logicals, uint64ToGpointer(logical));
  if (count_pointer == nullptr)
    return 0;
  int count = GPOINTER_TO_INT(count_pointer);
  if (count == 1) {
    g_hash_table_insert(pressed_logicals, uint64ToGpointer(logical), GINT_TO_POINTER(count - 1));
  } else {
    g_hash_table_remove(pressed_logicals, uint64ToGpointer(logical));
  }
  return count;
}

// Assign pressing_records[physical] = logical, and increase
// pressed_logicals[logical].
//
// The pressed_logicals[original_logical] is not changed.
//
// Returns the new logical pressing count.
static int assign_pressed_logical(GHashTable* pressing_records,
    GHashTable* pressed_logicals, uint64_t physical, uint64_t logical) {
  int logical_count = gpointerToInt(g_hash_table_lookup(pressed_logicals, uint64ToGpointer(logical)));
  g_hash_table_insert(pressed_logicals, uint64ToGpointer(logical), GINT_TO_POINTER(logical_count + 1));
  printf("insert %lu\n", physical);
  g_hash_table_insert(pressing_records, uint64ToGpointer(physical), uint64ToGpointer(logical));
  return logical_count + 1;
}

size_t fl_keyboard_manager_convert_key_event(FlKeyboardManager* self,
                                             const GdkEventKey* event,
                                             FlKeyDatum* result_physical,
                                             FlLogicalKeyDatum* result_logical) {
  if (self->character_to_free != nullptr) {
    g_free(self->character_to_free);
    self->character_to_free = nullptr;
  }
  uint64_t physical_key = event_to_physical_key(event, self->xkb_to_physical_key);
  uint64_t logical_key = event_to_logical_key(event, self->keyval_to_logical_key);
  bool is_physical_down = event->type == GDK_KEY_PRESS;

  uint64_t pressed_logical_key = pressed_logical_for_physical(self->pressing_records, physical_key);
  uint64_t last_logical_record = pressed_logical_key;
  uint64_t next_logical_record = is_physical_down ? logical_key : 0;

  size_t logical_data_count = 0;
  char* character_to_free = nullptr;
  bool is_repeated = false;

  printf("last %lu next %lu down %d\n", last_logical_record, next_logical_record, is_physical_down);
  fflush(stdout);

  if (last_logical_record != next_logical_record) {
      // Case 1: The pressing record for the physical key becomes a different
      // record from before.
      //
      //  * From null to non-null: Simple keydown
      //  * From non-null to null: Simple keyup
      //  * From non-null to a different non-null: The physical key starts to map
      //    to a different logical key. Cancel the previous one and sync the new one.

    int pressed_logical_key_last_count = pressed_logical_key == 0 ? 0 : 
        decrease_pressed_logical_count(self->pressed_logicals, pressed_logical_key);
    if (pressed_logical_key_last_count == 1) {
      FlLogicalKeyDatum* logical_datum = result_logical + (logical_data_count++);
      logical_datum->kind = next_logical_record == 0 ? kFlKeyDataKindUp : kFlKeyDataKindCancel;
      logical_datum->key = last_logical_record;
      logical_datum->repeated = false;
      logical_datum->character = NULL;
    }
    printf("beforeinsertsize %d\n", g_hash_table_size(self->pressing_records));
    int logical_key_next_count = next_logical_record == 0 ? 0 :
        assign_pressed_logical(self->pressing_records, self->pressed_logicals,
            physical_key, logical_key);
    printf("afterinsertsize %d\n", g_hash_table_size(self->pressing_records));
    if (logical_key_next_count == 1) {
      FlLogicalKeyDatum* logical_datum = result_logical + (logical_data_count++);
      logical_datum->kind = last_logical_record == 0 ? kFlKeyDataKindDown : kFlKeyDataKindSync;
      logical_datum->key = next_logical_record;
      logical_datum->repeated = false;
      character_to_free = event_to_character(event);
      logical_datum->character = character_to_free;
    }
    printf("pressed_last %d next %d\n", pressed_logical_key_last_count, logical_key_next_count);
    fflush(stdout);

    printf("beforesize %d\n", g_hash_table_size(self->pressing_records));
    if (next_logical_record == 0) {
      g_hash_table_remove(self->pressing_records, uint64ToGpointer(physical_key));
      printf("removed %lu\n", physical_key);
    }
    printf("aftersize %d\n", g_hash_table_size(self->pressing_records));
    fflush(stdout);

  } else if (next_logical_record != 0) {
    // Case 2: The pressing record for the physical key is a same non-null
    // record as before, but received an event anyway.
    //
    // GTK does not indicate whether an event is repeated, therefore we can only
    // assume they are all repeated.

    FlLogicalKeyDatum* logical_datum = result_logical + (logical_data_count++);
    logical_datum->kind = next_logical_record == 0 ? kFlKeyDataKindDown : kFlKeyDataKindUp;
    logical_datum->key = last_logical_record;
    logical_datum->repeated = true;
    character_to_free = event_to_character(event);
    logical_datum->character = character_to_free;
    is_repeated = true;
  } else {
    // Case 3: The physical record for the physical key is a same null state
    // as before, indicating an omitted down event, usually due to loss of
    // focus. Skip.
    return 0;
  }

  FlKeyDatum* physical_datum = result_physical + 0;
  physical_datum->logical_data_count = logical_data_count;
  physical_datum->timestamp = event_to_timestamp(event);
  physical_datum->active_locks = 0;
  physical_datum->kind = is_physical_down ? kFlKeyDataKindDown : kFlKeyDataKindUp;
  physical_datum->key = physical_key;
  physical_datum->repeated = is_repeated;

  return 1;
}

static void view_weak_notify_cb(gpointer user_data, GObject* object) {
  FlKeyboardManager* self = reinterpret_cast<FlKeyboardManager*>(user_data);
  self->view = nullptr;
}

static void fl_keyboard_manager_dispose(GObject* object) {
  FlKeyboardManager* self = FL_KEYBOARD_MANAGER(object);

  g_clear_pointer(&self->pressing_records, g_hash_table_unref);
  g_clear_pointer(&self->pressed_logicals, g_hash_table_unref);
  g_clear_pointer(&self->xkb_to_physical_key, g_hash_table_unref);
  g_clear_pointer(&self->keyval_to_logical_key, g_hash_table_unref);
  if (self->character_to_free != nullptr) {
    g_free(self->character_to_free);
  }

  G_OBJECT_CLASS(fl_keyboard_manager_parent_class)->dispose(object);
}

static void fl_keyboard_manager_class_init(FlKeyboardManagerClass* klass) {
  G_OBJECT_CLASS(klass)->dispose = fl_keyboard_manager_dispose;
}

static void fl_keyboard_manager_init(FlKeyboardManager* self) {
}

FlKeyboardManager* fl_keyboard_manager_new(FlView* view) {
  FlKeyboardManager* self = FL_KEYBOARD_MANAGER(
      g_object_new(fl_keyboard_manager_get_type(), nullptr));

  self->pressing_records = g_hash_table_new(g_direct_hash, g_direct_equal);
  self->pressed_logicals = g_hash_table_new(g_direct_hash, g_direct_equal);
  self->xkb_to_physical_key = g_hash_table_new(g_direct_hash, g_direct_equal);
  initialize_xkb_to_physical_key(self->xkb_to_physical_key);
  self->keyval_to_logical_key = g_hash_table_new(g_direct_hash, g_direct_equal);
  initialize_gtk_keyval_to_logical_key(self->keyval_to_logical_key);
  self->character_to_free = nullptr;

  self->view = view;
  g_object_weak_ref(G_OBJECT(view), view_weak_notify_cb, self);

  return self;
}
