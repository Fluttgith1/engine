// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "flutter/shell/platform/windows/flutter_keyboard_manager.h"

#include <windows.h>
#include <assert.h>

#include <chrono>
#include <iostream>
#include <string>
#include <codecvt>

#include "flutter/shell/platform/windows/string_conversion.h"

namespace flutter {

namespace {
}  // namespace

/**
 * The code prefix for keys which do not have a Unicode representation.
 *
 * This is used by platform-specific code to generate Flutter key codes using
 * HID Usage codes.
 */
constexpr uint64_t kHidPlane = 0x00100000000;

/**
 * The code prefix for keys which have a Unicode representation.
 *
 * This is used by platform-specific code to generate Flutter key codes.
 */
constexpr uint64_t kUnicodePlane = 0x00000000000;

/**
 */
constexpr uint64_t kWindowsKeyIdPlane = 0x00700000000;

/**
 * Mask for the auto-generated bit portion of the key code.
 * 
 * This is used by platform-specific code to generate new Flutter key codes
 * for keys which are not recognized.
 */
constexpr uint64_t kAutogeneratedMask = 0x10000000000;

FlutterKeyboardManager::FlutterKeyboardManager(std::function<void(const FlutterKeyEvent&)> onEvent)
    : onEvent_(onEvent) {}

FlutterKeyboardManager::~FlutterKeyboardManager() = default;

void FlutterKeyboardManager::TextHook(FlutterWindowsView* view,
                               const std::u16string& code_point) {}

static bool isAsciiPrintable(int codeUnit) {
  return codeUnit <= 0x7f && codeUnit >= 0x20;
}

static bool isControlCharacter(int codeUnit) {
  return (codeUnit <= 0x1f && codeUnit >= 0x00) || (codeUnit >= 0x7f && codeUnit <= 0x9f);
}

// Transform scancodes sent by windows to scancodes written in Chromium spec.
static int normalizeScancode(int windowsScanCode) {
  // Windows scancode is composed of 1 bit of "extended" and 8 bits of code,
  // concatenated (by Flutter embedding), i.e. PageUp is represented as 0x149.
  // In Chromium spec the extended bit is shown as 0xe000 bit, making PageUp
  // 0xe049.
  return (windowsScanCode & 0xff) | ((windowsScanCode & 0x100) ? 0xe000 : 0);
}

uint64_t FlutterKeyboardManager::getPhysicalKey(int scancode) {
  int chromiumScancode = normalizeScancode(scancode);
  printf("GetPhysical from %x to %x \n", scancode, chromiumScancode);
  auto resultIt = windowsToPhysicalMap_.find(chromiumScancode);
  if (resultIt != windowsToPhysicalMap_.end())
    return resultIt->second;
  return scancode | kHidPlane;
}

uint64_t FlutterKeyboardManager::getLogicalKey(int key, int scancode) {
  // Normally logical keys should only be derived from key codes, but since some
  // key codes are either 0 or ambiguous (multiple keys using the same key
  // code), these keys are resolved by scan codes.
  auto numpadIt = scanCodeToLogicalMap_.find(normalizeScancode(scancode));
  if (numpadIt != scanCodeToLogicalMap_.cend())
    return numpadIt->second;

  // Look to see if the keyCode is one we know about and have a mapping for.
  auto logicalIt = windowsToLogicalMap_.find(key);
  if (logicalIt != windowsToLogicalMap_.cend())
    return logicalIt->second;

  // Upper case letters should be normalized into lower case letters.
  if (isAsciiPrintable(key)) {
    if (isupper(key)) {
      return tolower(key);
    }
    return key;
  }

  // For keys that do not exist in the map, if it has a non-control-character
  // label, then construct a new Unicode-based key from it. Don't mark it as
  // autogenerated, since the label uniquely identifies an ID from the Unicode
  // plane.
  if (!isControlCharacter(key)) {
    return key | kUnicodePlane;
  } else {
    // This is a non-printable key that we don't know about, so we mint a new
    // code with the autogenerated bit set.
    return key | kWindowsKeyIdPlane | kAutogeneratedMask;
  }
}

void FlutterKeyboardManager::cacheUtf8String(char32_t character) {
  if (character == 0) {
    character_cache_[0] = '\0';
    return;
  }
  // TODO: Correctly handle UTF-32
  std::wstring text({static_cast<wchar_t>(character)});
  strcpy_s(character_cache_, kCharacterCacheSize, Utf8FromUtf16(text).c_str());
}

void FlutterKeyboardManager::KeyboardHook(FlutterWindowsView* view,
                                          int key,
                                          int scancode,
                                          int action,
                                          char32_t character,
                                          bool wasDown) {
  printf("#[%c] Key %x scan %x character %x wasDown %d",
    action == WM_KEYDOWN ? 'D' : 'U',
    key, scancode, character, wasDown
  );fflush(stdout);
  const uint64_t physical_key = getPhysicalKey(scancode);
  const uint64_t logical_key = getLogicalKey(key, scancode);
  assert(action == WM_KEYDOWN || action == WM_KEYUP);
  const bool is_physical_down = action == WM_KEYDOWN;

  auto lastLogicalRecordIter = pressingRecords_.find(physical_key);
  const bool hadRecord = lastLogicalRecordIter != pressingRecords_.end();
  const int lastLogicalRecord = hadRecord ?
      lastLogicalRecordIter->second : 0;

  FlutterKeyEventKind change;
  if (is_physical_down) {
    change = kFlutterKeyEventKindDown;
    if (hadRecord) {
      // This physical key is being pressed according to the record.
      if (wasDown) {
        // A normal repeated key.
        change = kFlutterKeyEventKindRepeat;
      } else {
        // A non-repeated key has been pressed that has the exact physical key as
        // a currently pressed one, usually indicating multiple keyboards are
        // pressing keys with the same physical key, or the up event was lost
        // during a loss of focus. The down event is ignored.
        return;
      }
    } else {
      // This physical key is not being pressed according to the record. It's a
      // normal down event, whether the system event is a repeat or not.
    }
  } else { // isPhysicalDown is false 
    // Handle key up of normal keys
    if (lastLogicalRecord == 0) {
      // The physical key has been released before. It indicates multiple
      // keyboards pressed keys with the same physical key. Ignore the up event.
      return;
    }

    change = kFlutterKeyEventKindUp;
  }

  bool nextHasRecord = true;
  int nextLogicalRecord;
  switch (change) {
    case kFlutterKeyEventKindDown:
      assert(!hadRecord);
      nextLogicalRecord = logical_key;
      break;
    case kFlutterKeyEventKindUp:
      assert(hadRecord);
      nextHasRecord = false;
      break;
    case kFlutterKeyEventKindRepeat:
      assert(hadRecord);
      nextLogicalRecord = lastLogicalRecord;
      break;
  }
  if (nextHasRecord) {
    pressingRecords_[physical_key] = nextLogicalRecord;
  } else {
    pressingRecords_.erase(lastLogicalRecordIter);
  }

  FlutterKeyEvent keyData = {};
  keyData.struct_size = sizeof(FlutterKeyEvent);
  keyData.timestamp = 
      std::chrono::duration_cast<std::chrono::microseconds>(
          std::chrono::high_resolution_clock::now().time_since_epoch())
          .count();
  keyData.kind = change;
  keyData.physical = physical_key;
  keyData.logical = logical_key;
  cacheUtf8String(character);
  if (character != 0) {
    printf(" Str|%s|\n", character_cache_);fflush(stdout);
  } else {
    printf("\n");fflush(stdout);
  }
  keyData.character = character_cache_;
  keyData.synthesized = false;
  onEvent_(keyData);
}

}  // namespace flutter
