// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// @dart = 2.6
import 'dart:io' as io;

import 'package:args/command_runner.dart';
import 'package:meta/meta.dart';
import 'package:path/path.dart' as pathlib;

/// An exception used to signal that the LUCI tool must exit.
///
/// The tool is expected to print the [message] and exit with the provided
/// [exitCode]. By default the tool should not print the stack trace from
/// this exception. The [message] is expected to contain all the information
/// relevant to the user, including stack traces, if any.
class ToolExit implements Exception {
  /// Creates an exception signalling the LUCI tool to exit.
  ToolExit(this.message, { this.exitCode = 1 });

  /// The error message.
  final String message;

  /// The exit code.
  final int exitCode;

  @override
  String toString() => '$ToolExit($exitCode): $message';
}

/// Contains various environment variables, such as common file paths and command-line options.
Environment get environment {
  _environment ??= Environment();
  return _environment;
}
Environment _environment;

/// Contains various environment variables, such as common file paths and command-line options.
class Environment {
  /// Scans the current directory and computes the surrounding environment information.
  factory Environment() {
    final io.File gclientFile = _findGclientFile();
    final io.Directory engineSrcDir = io.Directory(pathlib.join(gclientFile.parent.path, 'src'));
    final io.Directory repoDir = io.Directory(pathlib.join(engineSrcDir.path, 'flutter'));
    final io.Directory outDir = io.Directory(pathlib.join(engineSrcDir.path, 'out'));
    final io.Directory hostDebugUnoptDir = io.Directory(pathlib.join(outDir.path, 'host_debug_unopt'));
    final io.Directory dartSdkDir = io.Directory(pathlib.join(hostDebugUnoptDir.path, 'dart-sdk'));
    final io.Directory webUiRootDir = io.Directory(pathlib.join(engineSrcDir.path, 'flutter', 'lib', 'web_ui'));
    final io.Directory integrationTestsDir = io.Directory(pathlib.join(engineSrcDir.path, 'flutter', 'e2etests', 'web'));

    for (io.Directory expectedDirectory in <io.Directory>[engineSrcDir, outDir, hostDebugUnoptDir, dartSdkDir, webUiRootDir]) {
      if (!expectedDirectory.existsSync()) {
        throw ToolExit('$expectedDirectory does not exist.');
      }
    }

    return Environment._(
      luciScript: io.File(pathlib.join(repoDir.path, 'tools', 'luci', 'bin', 'luci.dart')),
      engineSrcDir: engineSrcDir,
      repoDirectory: repoDir,
      webUiRootDir: webUiRootDir,
      integrationTestsDir: integrationTestsDir,
      outDir: outDir,
      hostDebugUnoptDir: hostDebugUnoptDir,
      dartSdkDir: dartSdkDir,
    );
  }

  Environment._({
    this.luciScript,
    this.engineSrcDir,
    this.repoDirectory,
    this.webUiRootDir,
    this.integrationTestsDir,
    this.outDir,
    this.hostDebugUnoptDir,
    this.dartSdkDir,
  });

  /// The `luci.dart` script.
  final io.File luciScript;

  /// Path to the "web_ui" package sources.
  final io.Directory webUiRootDir;

  /// Path to the engine's "src" directory.
  final io.Directory engineSrcDir;

  /// Path to the web integration tests.
  final io.Directory integrationTestsDir;

  /// Path to the engine's "out" directory.
  ///
  /// This is where you'll find the ninja output, such as the Dart SDK.
  final io.Directory outDir;

  /// The "host_debug_unopt" build of the Dart SDK.
  final io.Directory hostDebugUnoptDir;

  /// The root of the Dart SDK.
  final io.Directory dartSdkDir;

  /// The "dart" executable file.
  String get dartExecutable => pathlib.join(dartSdkDir.path, 'bin', 'dart');

  /// The "pub" executable file.
  String get pubExecutable => pathlib.join(dartSdkDir.path, 'bin', 'pub');

  /// The "dart2js" executable file.
  String get dart2jsExecutable => pathlib.join(dartSdkDir.path, 'bin', 'dart2js');

  /// The "felt" executable file.
  String get feltExecutable => pathlib.join(webUiRootDir.path, 'dev', 'felt');

  /// Path to where github.com/flutter/engine is checked out inside the engine workspace.
  final io.Directory repoDirectory;

  /// Path to the `web_ui` directory.
  io.Directory get webSdkRootDir => io.Directory(pathlib.join(
    repoDirectory.path,
    'web_sdk',
  ));

  /// Path to the "web_engine_tester" package.
  io.Directory get webEngineTesterRootDir => io.Directory(pathlib.join(
    webSdkRootDir.path,
    'web_engine_tester',
  ));

  /// Path to the "build" directory, generated by "package:build_runner".
  ///
  /// This is where compiled output goes.
  io.Directory get webUiBuildDir => io.Directory(pathlib.join(
    webUiRootDir.path,
    'build',
  ));

  /// Path to the ".dart_tool" directory, generated by various Dart tools.
  io.Directory get webUiDartToolDir => io.Directory(pathlib.join(
    webUiRootDir.path,
    '.dart_tool',
  ));

  /// Path to the "dev" directory containing engine developer tools and
  /// configuration files.
  io.Directory get webUiDevDir => io.Directory(pathlib.join(
    webUiRootDir.path,
    'dev',
  ));

  /// Path to the clone of the flutter/goldens repository.
  io.Directory get webUiGoldensRepositoryDirectory => io.Directory(pathlib.join(
    webUiDartToolDir.path,
    'goldens',
  ));
}

/// Looks for the `.gclient` file starting from the current directory up.
io.File _findGclientFile() {
  io.Directory current = io.Directory.current;
  while (true) {
    current = current.parent;
    final io.File gclientFile = current.listSync().whereType<io.File>().firstWhere(
      (io.File file) => pathlib.basename(file.path) == '.gclient',
      orElse: () => null,
    );
    if (gclientFile != null) {
      return gclientFile;
    }
    if (current == null) {
      throw ToolExit(
        '.gclient file not found. Please run the luci.dart command from '
        'inside the flutter/engine checkout.'
      );
    }
  }
}

/// Runs [executable] merging its output into the current process' standard out and standard error.
Future<int> runProcess(
  String executable,
  List<String> arguments, {
  String workingDirectory,
  bool mustSucceed = false,
}) async {
  final io.Process process = await io.Process.start(
    executable,
    arguments,
    workingDirectory: workingDirectory,
    // Running the process in a system shell for Windows. Otherwise
    // the process is not able to get Dart from path.
    runInShell: io.Platform.isWindows,
    mode: io.ProcessStartMode.inheritStdio,
  );
  final int exitCode = await process.exitCode;
  if (mustSucceed && exitCode != 0) {
    throw ProcessException(
      description: 'Sub-process failed.',
      executable: executable,
      arguments: arguments,
      workingDirectory: workingDirectory,
      exitCode: exitCode,
    );
  }
  return exitCode;
}

/// Runs [executable]. Do not follow the exit code or the output.
void startProcess(
  String executable,
  List<String> arguments, {
  String workingDirectory,
  bool mustSucceed = false,
}) async {
  final io.Process process = await io.Process.start(
    executable,
    arguments,
    workingDirectory: workingDirectory,
    // Running the process in a system shell for Windows. Otherwise
    // the process is not able to get Dart from path.
    runInShell: io.Platform.isWindows,
    mode: io.ProcessStartMode.inheritStdio,
  );
  processesToCleanUp.add(process);
}

/// Runs [executable] and returns its standard output as a string.
///
/// If the process fails, throws a [ProcessException].
Future<String> evalProcess(
  String executable,
  List<String> arguments, {
  String workingDirectory,
}) async {
  final io.ProcessResult result = await io.Process.run(
    executable,
    arguments,
    workingDirectory: workingDirectory,
  );
  if (result.exitCode != 0) {
    throw ProcessException(
      description: result.stderr as String,
      executable: executable,
      arguments: arguments,
      workingDirectory: workingDirectory,
      exitCode: result.exitCode,
    );
  }
  return result.stdout as String;
}

/// Thrown by process utility functions, such as [evalProcess], when a process
/// exits with a non-zero exit code.
@immutable
class ProcessException implements Exception {
  /// Instantiates a process exception.
  const ProcessException({
    @required this.description,
    @required this.executable,
    @required this.arguments,
    @required this.workingDirectory,
    @required this.exitCode,
  });

  /// Describes what went wrong.
  final String description;

  /// The executable used to start the process that failed.
  final String executable;

  /// Arguments passed to the [executable].
  final List<String> arguments;

  /// The working directory of the process.
  final String workingDirectory;

  /// The exit code that the process exited with, if it exited.
  final int exitCode;

  @override
  String toString() {
    final StringBuffer message = StringBuffer();
    message
      ..writeln(description)
      ..writeln('Command: $executable ${arguments.join(' ')}')
      ..writeln(
          'Working directory: ${workingDirectory ?? io.Directory.current.path}')
      ..writeln('Exit code: $exitCode');
    return '$message';
  }
}

/// Adds utility methods
mixin ArgUtils<T> on Command<T> {
  /// Extracts a boolean argument from [argResults].
  bool boolArg(String name) => argResults[name] as bool;

  /// Extracts a string argument from [argResults].
  String stringArg(String name) => argResults[name] as String;

  /// Extracts a integer argument from [argResults].
  ///
  /// If the argument value cannot be parsed as [int] throws an [ArgumentError].
  int intArg(String name) {
    final String rawValue = stringArg(name);
    if (rawValue == null) {
      return null;
    }
    final int value = int.tryParse(rawValue);
    if (value == null) {
      throw ArgumentError(
        'Argument $name should be an integer value but was "$rawValue"',
      );
    }
    return value;
  }
}

/// There might be proccesses started during the tests.
///
/// Use this list to store those Processes, for cleaning up before shutdown.
final List<io.Process> processesToCleanUp = <io.Process>[];

/// There might be temporary directories created during the tests.
///
/// Use this list to store those directories and for deleteing them before
/// shutdown.
final List<io.Directory> temporaryDirectories = <io.Directory>[];

typedef AsyncCallback = Future<void> Function();

/// There might be additional cleanup needs to be done after the tools ran.
///
/// Add these operations here to make sure that they will run before felt
/// exit.
final List<AsyncCallback> cleanupCallbacks = <AsyncCallback>[];

/// Cleanup the remaning processes, close open browsers, delete temp files.
Future<void> cleanup() async {
  // Cleanup remaining processes if any.
  if (processesToCleanUp.isNotEmpty) {
    for (io.Process process in processesToCleanUp) {
      process.kill();
    }
  }
  // Delete temporary directories.
  if (temporaryDirectories.isNotEmpty) {
    for (io.Directory directory in temporaryDirectories) {
      directory.deleteSync(recursive: true);
    }
  }

  for (AsyncCallback callback in cleanupCallbacks) {
    callback.call();
  }
}
