# Copyright 2013 The Flutter Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//flutter/common/config.gni")

if (flutter_runtime_mode == "jit_release") {
  android_zip_archive_dir = "android-$target_cpu-jit-release"
} else {
  android_zip_archive_dir = "android-$target_cpu"
  if (flutter_runtime_mode != "debug") {
    android_zip_archive_dir += "-$flutter_runtime_mode"
  }
}

# Creates a zip file in the $root_build_dir/zip_archives folder.
#
# The output variable specifies the name of the zip file to create.
# The files variable is an array of scopes that specify a source file or
# directory and a destination path in the archive to create.
#
# For example, to create a zip file named archive.zip with all files in the
# root directory of the archive:
#
# zip_bundle("sample") {
#   output = "archive.zip"
#   files = [
#     {
#       source = "$root_build_dir/some/path/to/lib.so"
#       destination = "lib.so"
#     },
#     {
#       source = "$root_build_dir/some/other/path/with/files"
#       destination = "other_files"
#     },
#   ]
# }
template("zip_bundle") {
  assert(defined(invoker.output), "output must be defined")
  assert(defined(invoker.files), "files must be defined as a list of scopes")
  action(target_name) {
    script = "//flutter/build/zip.py"
    outputs = [ "$root_build_dir/zip_archives/${invoker.output}" ]
    sources = []
    forward_variables_from(invoker, [ "visibility" ])
    deps = invoker.deps

    args = [
      "-o",
      rebase_path(outputs[0]),
    ]
    foreach(input, invoker.files) {
      args += [
        "-i",
        rebase_path(input.source),
        input.destination,
      ]
      sources += [ input.source ]
    }
  }
}

# Creates a zip file in the $root_build_dir/zip_archives folder.
#
# The output variable specifies the name of the zip file to create.
# The files variable is an array of scopes that specify a source file or
# directory and a destination path in the archive to create.
#
# For example, to create a zip file named archive.zip with all files in the
# root directory of the archive:
#
# zip_bundle("sample") {
#   output = "archive.zip"
#   files = [
#     {
#       source = rebase_path("$root_build_dir/some/path/to/lib.so")
#       destination = "lib.so"
#     },
#     {
#       source = rebase_path("$root_build_dir/some/other/path/with/files")
#       destination = "other_files"
#     },
#   ]
# }
template("zip_bundle_from_file") {
  assert(defined(invoker.output), "output must be defined")
  assert(defined(invoker.files), "files must be defined as a list of scopes")

  action(target_name) {
    forward_variables_from(invoker,
                           [
                             "visibility",
                             "deps",
                           ])
    script = "//flutter/build/zip.py"
    outputs = [ "$root_build_dir/zip_archives/${invoker.output}" ]
    sources = []
    location_source_path = "$target_gen_dir/zip_bundle.txt"
    write_file(location_source_path, invoker.files, "json")
    args = [
      "-o",
      rebase_path(outputs[0]),
      "-f",
      rebase_path(location_source_path),
    ]
  }
}

# Output:
# Creates a zip file in the $root_build_dir/zip_archives folder,
# with two files named "entitlements.txt" and "without_entitlements.txt".
#
# Background:
# All Mac engine binaries need to be codesigned, either with entilements
# ( run on host ), or without entitlements (run on device).
# entitlement.txt contains the file paths of Mac binaries that should be
# code signed [with] entitlements.
# without_entitlement.txt contains the file paths of Mac binaries that
# should be code signed [without] entitlements.
#
# Variables:
# The output variable specifies the name of the zip file to create.
# The files variable is an array of scopes that specify a source file or
# directory and a destination path in the archive to create.
# The file_with_entitlements variable specifies the list of file paths of
# mac engine binaries that should be code signed with entitlements.
# The file_without_entitlements variable specifies the list of file paths
# of mac engine binaries that should be code signed without entitlements.
#
#
# For example, to create a zip file named archive.zip
#   1. with all files in the root directory of the archive
#   2. set entitlements.txt to contain two file paths, "flutter_tester"
#      and "gen_snapshot"
#   3. set without_entitlements.txt to contain one file path,
#      "FlutterMacOS.framework.zip/Versions/A/FlutterMacOS"
#
# zip_bundle_with_entitlements("sample") {
#   output = "archive.zip"
#   files = [
#     {
#       source = rebase_path("$root_build_dir/some/path/to/lib.so")
#       destination = "lib.so"
#     },
#     {
#       source = rebase_path("$root_build_dir/some/other/path/with/files")
#       destination = "other_files"
#     },
#   ]
#   file_with_entitlements = [ "flutter_tester", "gen_snapshot" ]
#   file_without_entitlements = [
#     "FlutterMacOS.framework.zip/Versions/A/FlutterMacOS"
#   ]
# }
template("zip_bundle_with_entitlements") {
  assert(defined(invoker.output), "output must be defined")
  assert(defined(invoker.files), "files must be defined as a list of scopes")
  action(target_name) {
    script = "//flutter/build/zip.py"
    outputs = [ "$root_build_dir/zip_archives/${invoker.output}" ]
    sources = []
    forward_variables_from(invoker, [ "visibility" ])
    deps = invoker.deps

    write_file("$target_gen_dir/entitlements.txt",
               invoker.file_with_entitlements)
    write_file("$target_gen_dir/without_entitlements.txt",
               invoker.file_without_entitlements)
    copy_files = invoker.files
    copy_files += [
      {
        source = "$target_gen_dir/entitlements.txt"
        destination = "entitlements.txt"
      },
      {
        source = "$target_gen_dir/without_entitlements.txt"
        destination = "without_entitlements.txt"
      },
    ]

    args = [
      "-o",
      rebase_path(outputs[0]),
    ]

    foreach(input, copy_files) {
      args += [
        "-i",
        rebase_path(input.source),
        input.destination,
      ]
      sources += [ input.source ]
    }
  }
}
