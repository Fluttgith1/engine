// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

// DO NOT EDIT -- DO NOT EDIT -- DO NOT EDIT
//
// This file is auto generated by flutter/engine:flutter/tools/gen_web_keyboard_layouts based on
// layout_types.dart in the same pacakge.
//
// Edit the following files instead:
//
//  - Script: lib/main.dart
//  - Templates: data/*.tmpl
//
// See flutter/engine:flutter/tools/gen_web_keyboard_layouts/README.md for more information.

part of web_keyboard_layouts;

/// The platform that the browser is running on.
enum LayoutPlatform {
  /// Windows.
  win,
  /// Linux.
  linux,
  /// MacOS or iOS.
  darwin,
}

// The length of [LayoutEntry.printable].
const int _kPrintableLength = 4;

/// Describes the characters that a physical keyboard key will be mapped to
/// under different modifier states, for a given language on a given
/// platform.
class LayoutEntry {
  /// Create a layout entry.
  LayoutEntry(this.printables, this.deadMasks)
    : assert(printables.length == _kPrintableLength);

  /// The printable characters that a key should be mapped to under different
  /// modifier states.
  ///
  /// The [printables] always have a length of 4, corresponding to "without any
  /// modifiers", "with Shift", "with AltGr", and "with Shift and AltGr"
  /// respectively. Some values might be empty, or be dead keys that are
  /// indiecated by [deadMasks].
  final List<String> printables;

  /// Whether the outcome of a key is a dead key under different modifier
  /// states.
  ///
  /// The four LSB [deadMasks] correspond to the four conditions of
  /// [printables]: 0x1 for "without any modifiers", 0x2 for "with Shift",
  /// 0x4 for "with AltGr", and 0x8 for "with Shift and AltGr". A set bit means
  /// the character is a dead key.
  final int deadMasks;

  /// An empty [LayoutEntry] that produces dead keys under all conditions.
  static final LayoutEntry empty = LayoutEntry(
    const <String>['', '', '', ''], 0xf);
}

/// Describes the characters that all goal keys will be mapped to for a given
/// language on a given platform.
class Layout {
  /// Create a [Layout].
  const Layout(this.language, this.platform, this.entries);

  /// The language being used.
  final String language;

  /// The platform that the browser is running on.
  final LayoutPlatform platform;

  /// Maps from DOM `KeyboardKey.code`s to the characters they produce.
  final Map<String, LayoutEntry> entries;
}

/// Describes all information needed to detect keyboard layout for any languages
/// on any platforms.
class LayoutStore {
  /// Create a [LayoutStore].
  const LayoutStore(this.goals, this.layouts);

  /// The list of goals, mapping from DOM `KeyboardKey.code` to their mandatory
  /// goal characters, or null if this goal is optional.
  ///
  /// Mandatory goals are characters that must be fulfilled during keyboard
  /// layout detection. If the character of a mandatory goal is not assigned in
  /// earlier stages, this character (the value of this map) will be assigned
  /// to its corresponding key (the key of this map).
  ///
  /// Optional goals are keys that will be tested to see if they can be mapped
  /// to mandatory goal characters.
  final Map<String, String?> goals;

  /// The layout information for different languages on different platforms.
  final List<Layout> layouts;
}

// A [ByteBuffer] that records a offset for the convenience of reading
// sequentially.
class _ByteStream {
  _ByteStream(this.buffer)
    : _data = buffer.asByteData(), _offset = 0;

  final ByteBuffer buffer;
  final ByteData _data;

  // The current offset.
  //
  // The next read will start from this byte (inclusive).
  int get offest => _offset;
  int _offset;

  // Read the next byte as an 8-bit unsigned integer, and increase [offset] by
  // 1.
  int readUint8() {
    final int result = _data.getUint8(_offset);
    _offset += 1;
    return result;
  }

  // Read the next few bytes as a UTF-8 string, and increase [offset]
  // accordingly.
  //
  // The first byte will be a uint8, `length`, the number of bytes of the UTF-8
  // sequence. Following that is the UTF-8 sequence. Therefore, the total
  // increment for [offset] is `length + 1`.
  //
  // If the `length` is 0, then an empty string is returned.
  String readString() {
    final int length = _data.getUint8(_offset);
    if (length == 0) {
      _offset += 1;
      return '';
    }
    final Uint8List bytes = buffer.asUint8List(_offset + 1, length);
    final String result = utf8.decode(bytes);
    _offset += 1 + length;
    return result;
  }

  // Read the next few bytes as a nullable UTF-8 string, and increase [offset]
  // accordingly.
  //
  // It is the same as [readString], except that if the `length` is 0, a null is
  // returned.
  String? readNullableString() {
    final int length = _data.getUint8(_offset);
    if (length == 0) {
      _offset += 1;
      return null;
    }
    return readString();
  }
}

/// Decode a [LayoutStore] out of the compressed binary data.
LayoutStore unmarshallStoreCompressed(String compressed) {
  final Uint8List bytes = Uint8List.fromList(gzip.decode(base64.decode(compressed)));
  return _unmarshallStore(bytes.buffer);
}

LayoutStore _unmarshallStore(ByteBuffer buffer) {
  final _ByteStream stream = _ByteStream(buffer);
  final Map<String, String?> goals = _unmarshallGoals(stream);
  final List<String> goalKeys = goals.keys.toList();
  final int layoutNum = stream.readUint8();
  final List<Layout> layouts = List<Layout>.generate(layoutNum, (_) {
    return _unmarshallLayout(stream, goalKeys);
  });
  return LayoutStore(goals, layouts);
}

Map<String, String?> _unmarshallGoals(_ByteStream stream) {
  final int goalsLength = stream.readUint8();
  return Map<String, String?>.fromEntries((() sync* {
    for (int goalIndex = 0; goalIndex < goalsLength; goalIndex += 1) {
      yield MapEntry<String, String?>(stream.readString(), stream.readNullableString());
    }
  })());
}

Layout _unmarshallLayout(_ByteStream stream, List<String> goalKeys) {
  final String language = stream.readString();
  final LayoutPlatform platform = LayoutPlatform.values[stream.readUint8()];
  final Map<String, LayoutEntry> entries = Map<String, LayoutEntry>.fromIterables(
    goalKeys,
    goalKeys.map((_) => _unmarshallLayoutEntry(stream)),
  );
  return Layout(language, platform, entries);
}

LayoutEntry _unmarshallLayoutEntry(_ByteStream stream) {
  final List<String> printables = List<String>.generate(_kPrintableLength,
    (_) => stream.readString());
  final int deadMasks = stream.readUint8();
  return LayoutEntry(printables, deadMasks);
}
