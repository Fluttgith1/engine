//---------------------------------------------------------------------------------------------
//  Copyright (c) 2022 Google LLC
//  Licensed under the MIT License. See License.txt in the project root for license information.
//--------------------------------------------------------------------------------------------*/

// DO NOT EDIT -- DO NOT EDIT -- DO NOT EDIT
//
// This file is auto generated by flutter/engine:flutter/tools/gen_web_keyboard_layouts based on
// https://github.com/microsoft/vscode/tree/ae34e8d2df286f8c8882d22db417e6dc4cdb01f5/src/vs/workbench/services/keybinding/browser/keyboardLayouts
//
// Edit the following files instead:
//
//  - Script: lib/main.dart
//  - Templates: data/*.tmpl
//
// See flutter/engine:flutter/tools/gen_web_keyboard_layouts/README.md for more information.

/// Used in the final mapping indicating the logical key should be derived from
/// KeyboardEvent.keyCode.
///
/// This value is chosen because it's a printable character within EASCII that
/// will never be mapped to (checked in the marshalling algorithm).
const int kUseKeyCode = 0xFF;

/// Used in the final mapping indicating the event key is 'Dead', the dead key.
final String _kUseDead = String.fromCharCode(0xFE);

/// The KeyboardEvent.key for a dead key.
const String _kEventKeyDead = 'Dead';

/// A map of all goals from the scan codes to their mapped value in US layout.
const Map<String, String> kLayoutGoals = <String, String>{
  'KeyA': 'A',
  'KeyB': 'B',
  'KeyC': 'C',
  'KeyD': 'D',
  'KeyE': 'E',
  'KeyF': 'F',
  'KeyG': 'G',
  'KeyH': 'H',
  'KeyI': 'I',
  'KeyJ': 'J',
  'KeyK': 'K',
  'KeyL': 'L',
  'KeyM': 'M',
  'KeyN': 'N',
  'KeyO': 'O',
  'KeyP': 'P',
  'KeyQ': 'Q',
  'KeyR': 'R',
  'KeyS': 'S',
  'KeyT': 'T',
  'KeyU': 'U',
  'KeyV': 'V',
  'KeyW': 'W',
  'KeyX': 'X',
  'KeyY': 'Y',
  'KeyZ': 'Z',
  'Digit1': '1',
  'Digit2': '2',
  'Digit3': '3',
  'Digit4': '4',
  'Digit5': '5',
  'Digit6': '6',
  'Digit7': '7',
  'Digit8': '8',
  'Digit9': '9',
  'Digit0': '0',
  'Minus': '-',
  'Equal': '=',
  'BracketLeft': '[',
  'BracketRight': ']',
  'Backslash': r'\',
  'Semicolon': ';',
  'Quote': "'",
  'Backquote': '`',
  'Comma': ',',
  'Period': '.',
  'Slash': '/',
};

final int _kLowerA = 'a'.codeUnitAt(0);
final int _kUpperA = 'A'.codeUnitAt(0);
final int _kLowerZ = 'z'.codeUnitAt(0);
final int _kUpperZ = 'Z'.codeUnitAt(0);
final int _k0 = '0'.codeUnitAt(0);
final int _k9 = '9'.codeUnitAt(0);

bool _isAscii(String key) {
  if (key.length != 1) {
    return false;
  }
  // 0x20 is the first printable character in ASCII.
  return key.codeUnitAt(0) >= 0x20 && key.codeUnitAt(0) <= 0x7F;
}

/// Returns whether the `char` is a single character of a letter or a digit.
bool isAlnum(String char) {
  if (char.length != 1) {
    return false;
  }
  final int charCode = char.codeUnitAt(0);
  return (charCode >= _kLowerA && charCode <= _kLowerZ)
      || (charCode >= _kUpperA && charCode <= _kUpperZ)
      || (charCode >= _k0 && charCode <= _k9);
}

/// A set of rules that can derive a large number of logical keys simply from
/// the event's code and key.
///
/// This greatly reduces the entries needed in the final mapping.
int? heuristicMapper(String code, String key) {
  if (isAlnum(key)) {
    return key.toLowerCase().codeUnitAt(0);
  }
  if (!_isAscii(key)) {
    return kLayoutGoals[code]!.codeUnitAt(0);
  }
  return null;
}

// Maps an integer to a printable EASCII character by adding it to this value.
//
// We could've chosen 0x20, the first printable character, for a slightly bigger
// range, but it's prettier this way and sufficient.
final int _kMarshallIntBase = '0'.codeUnitAt(0);

class _StringStream {
  _StringStream(this._data) : _offset = 0;

  final String _data;

  int get offest => _offset;
  int _offset;

  int readIntAsVerbatim() {
    final int result = _data.codeUnitAt(_offset);
    _offset += 1;
    assert(result >= _kMarshallIntBase);
    return result - _kMarshallIntBase;
  }

  int readIntAsChar() {
    final int result = _data.codeUnitAt(_offset);
    _offset += 1;
    return result;
  }

  String readEventKey() {
    final String char = String.fromCharCode(readIntAsChar());
    if (char == _kUseDead) {
      return _kEventKeyDead;
    } else {
      return char;
    }
  }

  String readString() {
    final int length = readIntAsVerbatim();
    if (length == 0) {
      return '';
    }
    final String result = _data.substring(_offset, _offset + length);
    _offset += length;
    return result;
  }
}

Map<String, int> _unmarshallCodeMap(_StringStream stream) {
  final int entryNum = stream.readIntAsVerbatim();
  return Map<String, int>.fromEntries((() sync* {
    for (int entryIndex = 0; entryIndex < entryNum; entryIndex += 1) {
      yield MapEntry<String, int>(stream.readEventKey(), stream.readIntAsChar());
    }
  })());
}

/// Decode a key mapping data out of the string.
Map<String, Map<String, int>> unmarshallMappingData(String compressed) {
  final _StringStream stream = _StringStream(compressed);
  final int eventCodeNum = stream.readIntAsVerbatim();
  return Map<String, Map<String, int>>.fromEntries((() sync* {
    for (int eventCodeIndex = 0; eventCodeIndex < eventCodeNum; eventCodeIndex += 1) {
      yield MapEntry<String, Map<String, int>>(stream.readString(), _unmarshallCodeMap(stream));
    }
  })());
}

/// Data for [LocaleKeymap] on Windows.
///
/// Do not use this value, but [LocaleKeymap.win] instead.
///
/// The keys are `KeyboardEvent.code` and then `KeyboardEvent.key`. The values
/// are logical keys or [kUseKeyCode]. Entries that can be derived using
/// heuristics have been omitted.
Map<String, Map<String, int>> getMappingDataWin() {
  return unmarshallMappingData(
    'V9Backquote1§06Digit04)0=0@0}06Digit17!1&1\'1+1>1|1~16Digit25"2\'2'
    '/2@2~26Digit36"3#3*3+3-3^36Digit47!4\$4\'4+4;4{4~46Digit53%5(5[56D'
    r'igit66&6-6/6:6^6|66Digit77&7/7=7?7`7{7|76Digit86!8(8*8[8\8_86Dig'
    r'it95(9)9]9^9{94KeyA4AAQQaAqQ4KeyB3BBbB{B4KeyC3&CCCcC4KeyD2DDdD4K'
    r'eyE2EEeE4KeyF3FF[FfF4KeyG3GG]GgG4KeyH2HHhH4KeyI2IIiI4KeyJ2JJjJ4K'
    r'eyK2KKkK4KeyL2LLlL4KeyM4<M?MMMmM4KeyN3NNnN}N4KeyO2OOoO4KeyP2PPpP'
    r'4KeyQ7/Q@QAAQQ\QaAqQ4KeyR2RRrR4KeyS2SSsS4KeyT2TTtT4KeyU2UUuU4Key'
    r'V3@VVVvV4KeyW7"W?WWWZZwWzZ|W4KeyX4#X)XXXxX4KeyY4YYZZyYzZ4KeyZ8(Z'
    r'>YWWYYZZwWyYzZ9Semicolon2MMmM'); // 541 characters
}

/// Data for [LocaleKeymap] on Linux.
///
/// Do not use this value, but [LocaleKeymap.linux] instead.
///
/// The keys are `KeyboardEvent.code` and then `KeyboardEvent.key`. The values
/// are logical keys or [kUseKeyCode]. Entries that can be derived using
/// heuristics have been omitted.
Map<String, Map<String, int>> getMappingDataLinux() {
  return unmarshallMappingData(
    r'U6Digit04)0=0@0}06Digit13!1&1|16Digit23"2@2~26Digit32"3#36Digit4'
    r"5$4'4;4{4~46Digit53%5(5[56Digit65&6-6:6^6|66Digit75&7/7?7`7{76Di"
    r'git85(8*8[8\8_86Digit94(9)9]9^94KeyA6@QAAQQaAqQΩQ4KeyB2BBbB4KeyC'
    r'2CCcC4KeyD2DDdD4KeyE2EEeE4KeyF2FFfF4KeyG2GGgG4KeyH2HHhH4KeyI2IIi'
    r'I4KeyJ2JJjJ4KeyK3&KKKkK4KeyL2LLlL4KeyM2MMmM4KeyN2NNnN4KeyO2OOoO4'
    r'KeyP2PPpP4KeyQ7@QAAQQaAqQÆAæA4KeyR2RRrR4KeyS2SSsS4KeyT2TTtT4KeyU'
    r'2UUuU4KeyV2VVvV4KeyW6<ZWWZZwWzZ«Z4KeyX3>XXXxX4KeyY6YYZZyYzZ¥ÿ←ÿ4'
    r'KeyZ;<ZWWYYZZwWyYzZ»YŁWłW›Y9Semicolon4MMmMµMºM'); // 494 characters
}

/// Data for [LocaleKeymap] on Darwin.
///
/// Do not use this value, but [LocaleKeymap.darwin] instead.
///
/// The keys are `KeyboardEvent.code` and then `KeyboardEvent.key`. The values
/// are logical keys or [kUseKeyCode]. Entries that can be derived using
/// heuristics have been omitted.
Map<String, Map<String, int>> getMappingDataDarwin() {
  return unmarshallMappingData(
    r'X5Comma4WWwW„W∑W6Digit04)0=0`0}06Digit13!1&1|16Digit22"2@26Digit'
    '32"3#36Digit43\$4%4\'46Digit56%5(5:5[5{5~56Digit65 6&6,6]6^66Digit'
    r"75&7.7/7\7|76Digit86!8(8*8;8[8{86Digit97 9'9(9)9]9{9}94KeyA6AAQQ"
    r'aAqQΩQ‡Q4KeyB6BBXXbBxX˛X≈X4KeyC7 CCCJJcCjJÔJ∆J4KeyD6DDþEEEdDeE´E'
    r'4KeyE2EEeE4KeyF6þUFFUUfFuU¨U4KeyG6þÿGGIIgGiIˆI4KeyH7 HDDHHdDhHÎÿ'
    r'∂D4KeyI7 ICCIIcCiIÇCçC4KeyJ6HHJJhHjJÓH˙H4KeyK6KKTTkKtTˇÿ†T4KeyL9'
    r' L@LþÿLLNNlLnN|L˜N4KeyM3MMmM~M4KeyN7 NBBNNbBnNıÿ∫B4KeyO6OORRoOrR'
    r'®R‰R4KeyP6LLPPlLpP¬LÒL4KeyQ6AAQQaAqQÆAæA4KeyR7 RPPRRpPrRπP∏P4Key'
    r'S7 SOOSSoOsSØOøO4KeyT6TTYYtTyY¥YÁY4KeyU7 UGGUUgGuU©G˝G4KeyV6KKVV'
    r'kKvV˚KK4KeyW6WWZZwWzZÂZÅZ4KeyX6QQXXqQxXŒQœQ4KeyY; YFFYYZZfFyYzZ'
    r'ÏFƒFˇZΩZ4KeyZ; ZWWYYZZwWyYzZ¥Y‡Y‹ÿ›W6Period4VVvV√V◊V9Semicolon8M'
    r'MSSmMsSµMÍSÓMßS5Slash4ZZzZ¸ZΩZ'); // 734 characters
}
