# Copyright 2013 The Flutter Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

if (is_android) {
  import("//build/config/android/config.gni")
}

import("//build/fuchsia/sdk.gni")

if (target_cpu == "arm" || target_cpu == "arm64") {
  import("//build/config/arm.gni")
}

if (is_fuchsia) {
  import("//build/toolchain/clang.gni")
}

declare_args() {
  # The runtime mode ("debug", "profile", "release", or "jit_release")
  flutter_runtime_mode = "debug"

  # Whether to use the Skia text shaper module
  flutter_enable_skshaper = false

  # A copy of the enable_bitcode flag from build/toolchain/clang.gni.
  # This needs to be mirrored here because build/toolchain/clang.gni does
  # not exist in the Fuchsia source tree.
  flutter_enable_bitcode = false
}

# feature_defines_list ---------------------------------------------------------

feature_defines_list = [
  "FLUTTER_RUNTIME_MODE_DEBUG=1",
  "FLUTTER_RUNTIME_MODE_PROFILE=2",
  "FLUTTER_RUNTIME_MODE_RELEASE=3",
  "FLUTTER_RUNTIME_MODE_JIT_RELEASE=4",
]

if (flutter_runtime_mode == "debug") {
  feature_defines_list += [
    "FLUTTER_RUNTIME_MODE=1",
    "FLUTTER_JIT_RUNTIME=1",
  ]
} else if (flutter_runtime_mode == "profile") {
  feature_defines_list += [ "FLUTTER_RUNTIME_MODE=2" ]
} else if (flutter_runtime_mode == "release") {
  feature_defines_list += [
    "FLUTTER_RUNTIME_MODE=3",
    "FLUTTER_RELEASE=1",
  ]
} else if (flutter_runtime_mode == "jit_release") {
  feature_defines_list += [
    "FLUTTER_RUNTIME_MODE=4",
    "FLUTTER_RELEASE=1",
    "FLUTTER_JIT_RUNTIME=1",
  ]
} else {
  feature_defines_list += [ "FLUTTER_RUNTIME_MODE=0" ]
}

if (is_fuchsia) {
  # TODO(chinmaygarde): This is always set. The macro may now be removed.
  feature_defines_list += [ "FUCHSIA_SDK=1" ]
}

if ((is_ios || is_mac) && defined(enable_bitcode)) {
  flutter_enable_bitcode = enable_bitcode
}

if (is_ios || is_mac) {
  flutter_cflags_objc = [
    "-Werror=overriding-method-mismatch",
    "-Werror=undeclared-selector",
  ]
  flutter_cflags_objcc = flutter_cflags_objc
}

# This template allows creating a `source_set` in both product and non-product
# configurations.
#
# `sources`, `public_configs`, `configs`, `public_deps`, `deps` work as they do
# in a normal `source_set`.
#
# `product_deps` is the list of dependencies which should be mutated by
# appending '_product' when creating the 2 `source_set`'s.  The template adds
# `product_deps` to `public_deps`, whether it mutates them or not.
template("source_set_maybe_product") {
  assert(defined(invoker.product_deps), "The product_deps must be specified.")

  product_suffix = "_product"
  srcs = []
  if (defined(invoker.sources)) {
    srcs += invoker.sources
  }
  pub_cfgs = []
  if (defined(invoker.public_configs)) {
    pub_cfgs += invoker.public_configs
  }
  priv_cfgs = []
  if (defined(invoker.configs)) {
    priv_cfgs += invoker.configs
  }
  pub_deps = []
  pub_deps_product = []
  if (defined(invoker.public_deps)) {
    pub_deps += invoker.public_deps
    pub_deps_product += invoker.public_deps
  }
  foreach(product_dep, invoker.product_deps) {
    pub_deps += [ product_dep ]
    pub_deps_product += [ product_dep + product_suffix ]
  }
  priv_deps = []
  if (defined(invoker.deps)) {
    priv_deps += invoker.deps
  }

  source_set(target_name) {
    sources = srcs

    public_configs = pub_cfgs
    configs += priv_cfgs

    public_deps = pub_deps
    deps = priv_deps
  }

  source_set(target_name + product_suffix) {
    sources = srcs

    public_configs = pub_cfgs
    configs += priv_cfgs

    public_deps = pub_deps_product
    deps = priv_deps
  }
}
