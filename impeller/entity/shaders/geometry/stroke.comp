// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
layout(local_size_x = 1024, local_size_y = 1) in;
layout(std430) buffer;

struct PolylineComponent {
  vec2 pt;
  // This is the end of a countour.
  //
  // that is path.close was called with this as the final
  // point.
  bool contour_end;

  // This point is the end of a line segment.
  bool segment_end;
};

layout(binding = 0) readonly buffer Polyline {
  uint count;
  PolylineComponent data[];
}
polyline;

layout(binding = 1) writeonly buffer Geometry {
  vec2 data[];
}
geometry;

layout(binding = 2) buffer IndirectCommandArguments {
  uint vertex_count;
  uint instance_count;
  uint vertex_start;
  uint base_instance;
}
indirect_command_arguments;

uniform Config {
  float width;
  uint cap;
  uint join;
  float miter_limit;
}
config;

vec2 compute_offset(uint index) {
  vec2 direction = normalize(polyline.data[index + 1].pt - polyline.data[index].pt);
  return vec2(-direction.y, direction.x) * config.width * .5;
}

void main() {
  uint ident = gl_GlobalInvocationID.x;
  if (ident >= polyline.count || ident == 0) {
    // This is ok because there is no barrier() below.
    return;
  }

  atomicAdd(indirect_command_arguments.vertex_count, 4);

  uint index = ident - 1;
  vec2 offset = compute_offset(index);
  geometry.data[index * 4 + 0] = polyline.data[ident - 1].pt + offset;
  geometry.data[index * 4 + 1] = polyline.data[ident - 1].pt - offset;
  geometry.data[index * 4 + 2] = polyline.data[ident].pt + offset;
  geometry.data[index * 4 + 3] = polyline.data[ident].pt - offset;

  // TODO(dnfield): Implement other cap/join mechanisms.
  if (ident == polyline.count - 1) {
    geometry.data[index * 4 + 4] = polyline.data[ident].pt + offset;
    geometry.data[index * 4 + 5] = polyline.data[ident].pt - offset;

    atomicAdd(indirect_command_arguments.vertex_count, 2);
  }
}
