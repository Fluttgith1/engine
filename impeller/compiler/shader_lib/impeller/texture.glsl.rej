***************
*** 5,19 ****
  #ifndef TEXTURE_GLSL_
  #define TEXTURE_GLSL_
  
- #include <impeller/types.glsl>
  #include <impeller/branching.glsl>
  
  /// Sample from a texture.
  ///
  /// If  < 0.0, the Y coordinate is flipped. This is useful
  /// for Impeller graphics backends that use a flipped framebuffer coordinate
  /// space.
- f16vec4 IPSample(sampler2D texture_sampler, f16vec2 coords, float16_t y_coord_scale) {
    if (y_coord_scale < 0.0hf) {
      coords.y = 1.0hf - coords.y;
    }
--- 5,21 ----
  #ifndef TEXTURE_GLSL_
  #define TEXTURE_GLSL_
  
  #include <impeller/branching.glsl>
+ #include <impeller/types.glsl>
  
  /// Sample from a texture.
  ///
  /// If  < 0.0, the Y coordinate is flipped. This is useful
  /// for Impeller graphics backends that use a flipped framebuffer coordinate
  /// space.
+ f16vec4 IPSample(sampler2D texture_sampler,
+                  f16vec2 coords,
+                  float16_t y_coord_scale) {
    if (y_coord_scale < 0.0hf) {
      coords.y = 1.0hf - coords.y;
    }
***************
*** 25,32 ****
  /// If  < 0.0, the Y coordinate is flipped. This is useful
  /// for Impeller graphics backends that use a flipped framebuffer coordinate
  /// space.
- /// The range of  will be mapped from [0, 1] to [half_texel, 1 - half_texel]
- f16vec4 IPSampleLinear(sampler2D texture_sampler, f16vec2 coords, float16_t y_coord_scale, f16vec2 half_texel) {
    coords.x = mix(half_texel.x, 1.0hf - half_texel.x, coords.x);
    coords.y = mix(half_texel.y, 1.0hf - half_texel.y, coords.y);
    return IPSample(texture_sampler, coords, y_coord_scale);
--- 27,38 ----
  /// If  < 0.0, the Y coordinate is flipped. This is useful
  /// for Impeller graphics backends that use a flipped framebuffer coordinate
  /// space.
+ /// The range of  will be mapped from [0, 1] to [half_texel, 1 -
+ /// half_texel]
+ f16vec4 IPSampleLinear(sampler2D texture_sampler,
+                        f16vec2 coords,
+                        float16_t y_coord_scale,
+                        f16vec2 half_texel) {
    coords.x = mix(half_texel.x, 1.0hf - half_texel.x, coords.x);
    coords.y = mix(half_texel.y, 1.0hf - half_texel.y, coords.y);
    return IPSample(texture_sampler, coords, y_coord_scale);
***************
*** 61,69 ****
  /// Remap a vec2 using a tiling mode.
  ///
  /// Runs each component of the vec2 through .
- f16vec2 IPVec2Tile(f16vec2 coords, float16_t x_tile_mode, float16_t y_tile_mode) {
    return f16vec2(IPFloatTile(coords.x, x_tile_mode),
-               IPFloatTile(coords.y, y_tile_mode));
  }
  
  /// Sample a texture, emulating a specific tile mode.
--- 67,77 ----
  /// Remap a vec2 using a tiling mode.
  ///
  /// Runs each component of the vec2 through .
+ f16vec2 IPVec2Tile(f16vec2 coords,
+                    float16_t x_tile_mode,
+                    float16_t y_tile_mode) {
    return f16vec2(IPFloatTile(coords.x, x_tile_mode),
+                  IPFloatTile(coords.y, y_tile_mode));
  }
  
  /// Sample a texture, emulating a specific tile mode.
***************
*** 99,113 ****
  ///
  /// This is useful for Impeller graphics backend that don't have native support
  /// for Decal.
- /// The range of  will be mapped from [0, 1] to [half_texel, 1 - half_texel]
  f16vec4 IPSampleLinearWithTileMode(sampler2D tex,
-                                 f16vec2 coords,
-                                 float16_t y_coord_scale,
-                                 f16vec2 half_texel,
-                                 float16_t x_tile_mode,
-                                 float16_t y_tile_mode) {
-   if (x_tile_mode == kTileModeDecal && (coords.x < 0.0hf || coords.x >= 1.0hf) ||
-       y_tile_mode == kTileModeDecal && (coords.y < 0.0hf || coords.y >= 1.0hf)) {
      return f16vec4(0.0hf);
    }
  
--- 107,124 ----
  ///
  /// This is useful for Impeller graphics backend that don't have native support
  /// for Decal.
+ /// The range of  will be mapped from [0, 1] to [half_texel, 1 -
+ /// half_texel]
  f16vec4 IPSampleLinearWithTileMode(sampler2D tex,
+                                    f16vec2 coords,
+                                    float16_t y_coord_scale,
+                                    f16vec2 half_texel,
+                                    float16_t x_tile_mode,
+                                    float16_t y_tile_mode) {
+   if (x_tile_mode == kTileModeDecal &&
+           (coords.x < 0.0hf || coords.x >= 1.0hf) ||
+       y_tile_mode == kTileModeDecal &&
+           (coords.y < 0.0hf || coords.y >= 1.0hf)) {
      return f16vec4(0.0hf);
    }
  
***************
*** 119,131 ****
  ///
  /// This is useful for Impeller graphics backend that don't have native support
  /// for Decal.
- /// The range of  will be mapped from [0, 1] to [half_texel, 1 - half_texel]
  f16vec4 IPSampleLinearWithTileMode(sampler2D tex,
                                     f16vec2 coords,
                                     float16_t y_coord_scale,
                                     f16vec2 half_texel,
                                     float16_t tile_mode) {
-   return IPSampleLinearWithTileMode(tex, coords, y_coord_scale, half_texel, tile_mode, tile_mode);
  }
  
  #endif
--- 130,144 ----
  ///
  /// This is useful for Impeller graphics backend that don't have native support
  /// for Decal.
+ /// The range of  will be mapped from [0, 1] to [half_texel, 1 -
+ /// half_texel]
  f16vec4 IPSampleLinearWithTileMode(sampler2D tex,
                                     f16vec2 coords,
                                     float16_t y_coord_scale,
                                     f16vec2 half_texel,
                                     float16_t tile_mode) {
+   return IPSampleLinearWithTileMode(tex, coords, y_coord_scale, half_texel,
+                                     tile_mode, tile_mode);
  }
  
  #endif
