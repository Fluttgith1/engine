// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "impeller/compiler/spirv_sksl.h"

using namespace spv;
using namespace SPIRV_CROSS_NAMESPACE;

namespace impeller {
namespace compiler {

std::string CompilerSkSL::compile() {
  // Do not deal with ES-isms like precision, older extensions and such.
  options.es = false;
  options.version = 450;
  options.vulkan_semantics = false;
  backend.allow_precision_qualifiers = false;
  backend.float_literal_suffix = false;
  backend.double_literal_suffix = false;
  backend.long_long_literal_suffix = false;
  backend.uint32_t_literal_suffix = false;
  backend.basic_int_type = "int";
  backend.basic_uint_type = "uint";
  backend.basic_int16_type = "short";
  backend.basic_uint16_type = "ushort";

  // TODO(zra): This doesn't work at least because we need to handle outputs
  // in a different way. Instead this should do what spirv_cpp.cpp does and
  // actually reimplement most of spirv_glsl.cpp.
  return spirv_cross::CompilerGLSL::compile();
}

void CompilerSkSL::emit_header() {
  statement("// This SkSL shader is autogenerated by spirv-cross.");
}

std::string CompilerSkSL::type_to_glsl(const spirv_cross::SPIRType& type,
                                       uint32_t id) {
  std::string result = spirv_cross::CompilerGLSL::type_to_glsl(type, id);

  // Rewrite the type where SkSL spells it differently.

  if (type.vecsize == 1 && type.columns == 1) {  // Scalar builtins.
    switch (type.basetype) {
      case SPIRType::Boolean:
        return "bool";
      case SPIRType::SByte:
        return backend.basic_int8_type;
      case SPIRType::UByte:
        return backend.basic_uint8_type;
      case SPIRType::Short:
        return backend.basic_int16_type;
      case SPIRType::UShort:
        return backend.basic_uint16_type;
      case SPIRType::Int:
        return backend.basic_int_type;
      case SPIRType::UInt:
        return backend.basic_uint_type;
      case SPIRType::AtomicCounter:
        return "atomic_uint";
      case SPIRType::Half:
        return "half";
      case SPIRType::Float:
        return "float";
      case SPIRType::Double:
        return "float";
      case SPIRType::Int64:
        return "int";
      case SPIRType::UInt64:
        return "uint";
      case SPIRType::Void:
        return "void";
      default:
        return "???";
    }
  } else if (type.vecsize > 1 && type.columns == 1) {  // Vector builtins.
    switch (type.basetype) {
      case SPIRType::Boolean:
        return join("bool", type.vecsize);
      case SPIRType::SByte:
        return join("i8vec", type.vecsize);
      case SPIRType::UByte:
        return join("u8vec", type.vecsize);
      case SPIRType::Short:
        return join("short", type.vecsize);
      case SPIRType::UShort:
        return join("ushort", type.vecsize);
      case SPIRType::Int:
        return join("int", type.vecsize);
      case SPIRType::UInt:
        return join("uint", type.vecsize);
      case SPIRType::Half:
        return join("half", type.vecsize);
      case SPIRType::Float:
        return join("float", type.vecsize);
      case SPIRType::Double:
        return join("float", type.vecsize);
      case SPIRType::Int64:
        return join("int", type.vecsize);
      case SPIRType::UInt64:
        return join("uint", type.vecsize);
      default:
        return "???";
    }
  } else if (type.vecsize == type.columns) {  // Simple Matrix builtin
    switch (type.basetype) {
      case SPIRType::Boolean:
        return join("bool", type.vecsize, "x", type.vecsize);
      case SPIRType::Int:
        return join("int", type.vecsize, "x", type.vecsize);
      case SPIRType::UInt:
        return join("uint", type.vecsize, "x", type.vecsize);
      case SPIRType::Half:
        return join("half", type.vecsize, "x", type.vecsize);
      case SPIRType::Float:
        return join("float", type.vecsize, "x", type.vecsize);
      case SPIRType::Double:
        return join("float", type.vecsize, "x", type.vecsize);
      // Matrix types not supported for int64/uint64.
      default:
        return "???";
    }
  } else {
    switch (type.basetype) {
      case SPIRType::Boolean:
        return join("bool", type.columns, "x", type.vecsize);
      case SPIRType::Int:
        return join("int", type.columns, "x", type.vecsize);
      case SPIRType::UInt:
        return join("uint", type.columns, "x", type.vecsize);
      case SPIRType::Half:
        return join("half", type.columns, "x", type.vecsize);
      case SPIRType::Float:
        return join("float", type.columns, "x", type.vecsize);
      case SPIRType::Double:
        return join("float", type.columns, "x", type.vecsize);
      // Matrix types not supported for int64/uint64.
      default:
        return "???";
    }
  }

  return result;
}

std::string CompilerSkSL::builtin_to_glsl(spv::BuiltIn builtin,
                                          spv::StorageClass storage) {
  std::string result =
      spirv_cross::CompilerGLSL::builtin_to_glsl(builtin, storage);

  switch (builtin) {
    case BuiltInPosition:
      return "sk_Position";
    case BuiltInPointSize:
      return "sk_PointSize";
    case BuiltInVertexId:
      return "sk_VertexID";
    case BuiltInInstanceId:
      return "sk_InstanceID";
    case BuiltInVertexIndex:
      return "sk_VertexID";
    case BuiltInInstanceIndex:
      return "sk_InstanceID";
    case BuiltInFragCoord:
      return "sk_FragCoord";
    case BuiltInFrontFacing:
      return "sk_Clockwise";
    default:
      break;
  }

  return result;
}

void CompilerSkSL::emit_uniform(const spirv_cross::SPIRVariable& var) {
  spirv_cross::CompilerGLSL::add_resource_name(var.self);
  spirv_cross::CompilerGLSL::statement(
      spirv_cross::CompilerGLSL::variable_decl(var), ";");
}

}  // namespace compiler
}  // namespace impeller
