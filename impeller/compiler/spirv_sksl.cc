// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "impeller/compiler/spirv_sksl.h"

using namespace spv;
using namespace SPIRV_CROSS_NAMESPACE;

namespace impeller {
namespace compiler {

std::string CompilerSkSL::compile() {
  ir.fixup_reserved_names();

  // Do not deal with ES-isms like precision, older extensions and such.
  options.es = false;
  options.version = 450;
  options.vulkan_semantics = false;

  backend.allow_precision_qualifiers = false;
  backend.basic_int16_type = "short";
  backend.basic_int_type = "int";
  backend.basic_uint16_type = "ushort";
  backend.basic_uint_type = "uint";
  backend.double_literal_suffix = false;
  backend.float_literal_suffix = false;
  backend.long_long_literal_suffix = false;
  backend.needs_row_major_load_workaround = true;
  backend.nonuniform_qualifier = "";
  backend.support_precise_qualifier = false;
  backend.uint32_t_literal_suffix = false;
  backend.use_array_constructor = true;
  backend.workgroup_size_is_hidden = true;

  fixup_anonymous_struct_names();
  fixup_type_alias();
  reorder_type_alias();
  build_function_control_flow_graphs_and_analyze();
  fixup_image_load_store_access();
  update_active_builtins();
  analyze_image_and_sampler_usage();
  analyze_interlocked_resource_usage();

  uint32_t pass_count = 0;
  do {
    reset(pass_count);

    // Move constructor for this type is broken on GCC 4.9 ...
    buffer.reset();

    emit_header();
    emit_resources();

    emit_function(get<SPIRFunction>(ir.default_entry_point), Bitset());

    pass_count++;
  } while (is_forcing_recompilation());

  statement("half4 main(float2 iFragCoord)");
  begin_scope();
  statement("  sk_FragCoord = float4(iFragCoord, 0, 0);");
  statement("  __main();");
  statement("  return " + output_name_ + ";");
  end_scope();

  return buffer.str();
}

void CompilerSkSL::emit_header() {
  statement("// This SkSL shader is autogenerated by spirv-cross.");
  statement("float4 sk_FragCoord;");
}

void CompilerSkSL::emit_resources() {
  bool emitted = false;

  for (auto& id : ir.ids) {
    if (id.get_type() == TypeConstant) {
      auto& c = id.get<SPIRConstant>();
      bool needs_declaration = c.specialization || c.is_used_as_lut;
      if (needs_declaration) {
        if (!options.vulkan_semantics && c.specialization) {
          c.specialization_constant_macro_name = constant_value_macro_name(
              get_decoration(c.self, DecorationSpecId));
        }
        emit_constant(c);
        emitted = true;
      }
    } else if (id.get_type() == TypeConstantOp) {
      emit_specialization_constant_op(id.get<SPIRConstantOp>());
      emitted = true;
    }
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Output all basic struct types which are not Block or BufferBlock as these
  // are declared inplace when such variables are instantiated.
  for (auto& id : ir.ids) {
    if (id.get_type() == TypeType) {
      auto& type = id.get<SPIRType>();
      if (type.basetype == SPIRType::Struct && type.array.empty() &&
          !type.pointer &&
          (!ir.meta[type.self].decoration.decoration_flags.get(
               DecorationBlock) &&
           !ir.meta[type.self].decoration.decoration_flags.get(
               DecorationBufferBlock))) {
        emit_struct(type);
        emitted = true;
      }
    }
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Output UBOs and SSBOs
  for (auto& id : ir.ids) {
    if (id.get_type() == TypeVariable) {
      auto& var = id.get<SPIRVariable>();
      auto& type = get<SPIRType>(var.basetype);

      if (var.storage != StorageClassFunction && type.pointer &&
          type.storage == StorageClassUniform && !is_hidden_variable(var) &&
          (ir.meta[type.self].decoration.decoration_flags.get(
               DecorationBlock) ||
           ir.meta[type.self].decoration.decoration_flags.get(
               DecorationBufferBlock))) {
        emit_buffer_block(var);
        emitted = true;
      }
    }
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Output push constant blocks
  for (auto& id : ir.ids) {
    if (id.get_type() == TypeVariable) {
      auto& var = id.get<SPIRVariable>();
      auto& type = get<SPIRType>(var.basetype);
      if (!is_hidden_variable(var) && var.storage != StorageClassFunction &&
          type.pointer && type.storage == StorageClassPushConstant) {
        emit_push_constant_block(var);
        emitted = true;
      }
    }
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Output Uniform Constants (values, samplers, images, etc).
  std::vector<spirv_cross::SPIRVariable*> uniforms;
  for (auto& id : ir.ids) {
    if (id.get_type() == TypeVariable) {
      auto& var = id.get<SPIRVariable>();
      auto& type = get<SPIRType>(var.basetype);
      if (var.storage != StorageClassFunction && !is_hidden_variable(var) &&
          type.pointer &&
          (type.storage == StorageClassUniformConstant ||
           type.storage == StorageClassAtomicCounter)) {
        uniforms.push_back(&var);
        emitted = true;
      }
    }
  }

  // The uniforms have to be emitted in order of increasing location.
  std::sort(
      uniforms.begin(), uniforms.end(),
      [this](spirv_cross::SPIRVariable* var1, spirv_cross::SPIRVariable* var2) {
        if (!has_decoration(var1->self, DecorationLocation) ||
            !has_decoration(var2->self, DecorationLocation)) {
          return false;
        }
        return get_decoration(var1->self, DecorationLocation) <
               get_decoration(var2->self, DecorationLocation);
      });

  for (auto var : uniforms) {
    emit_uniform(*var);
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Output in/out interfaces.
  for (auto& id : ir.ids) {
    if (id.get_type() == TypeVariable) {
      auto& var = id.get<SPIRVariable>();
      auto& type = get<SPIRType>(var.basetype);
      if (var.storage != StorageClassFunction && !is_hidden_variable(var) &&
          type.pointer &&
          (var.storage == StorageClassInput ||
           var.storage == StorageClassOutput) &&
          interface_variable_exists_in_entry_point(var.self)) {
        emit_interface_block(var);
        emitted = true;
      }
    }
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Global variables.
  for (auto global : global_variables) {
    auto& var = get<SPIRVariable>(global);
    if (is_hidden_variable(var, true)) {
      continue;
    }
    if (var.storage != StorageClassOutput) {
      if (!variable_is_lut(var)) {
        add_resource_name(var.self);
        std::string initializer;
        if (options.force_zero_initialized_variables &&
            var.storage == StorageClassPrivate && !var.initializer &&
            !var.static_expression &&
            type_can_zero_initialize(get_variable_data_type(var))) {
          initializer = join(" = ", to_zero_initialized_expression(
                                        get_variable_data_type_id(var)));
        }
        statement(variable_decl(var), initializer, ";");
        emitted = true;
      }
    } else if (var.initializer &&
               maybe_get<SPIRConstant>(var.initializer) != nullptr) {
      emit_output_variable_initializer(var);
    }
  }

  if (emitted) {
    statement("");
  }

  declare_undefined_values();
}

void CompilerSkSL::emit_interface_block(const SPIRVariable& var) {
  auto& type = get<SPIRType>(var.basetype);

  const char* qual = to_storage_qualifiers_glsl(var);

  // Either make it plain in/out or in/out blocks depending on what shader is
  // doing ...
  bool block =
      ir.meta[type.self].decoration.decoration_flags.get(DecorationBlock);
  if (block) {
    // Workaround to make sure we can emit "patch in/out" correctly.
    fixup_io_block_patch_qualifiers(var);

    // Block names should never alias.
    auto block_name = to_name(type.self, false);

    // The namespace for I/O blocks is separate from other variables in GLSL.
    auto& block_namespace = type.storage == StorageClassInput
                                ? block_input_names
                                : block_output_names;

    // Shaders never use the block by interface name, so we don't
    // have to track this other than updating name caches.
    if (block_name.empty() ||
        block_namespace.find(block_name) != end(block_namespace)) {
      block_name = get_fallback_name(type.self);
    } else {
      block_namespace.insert(block_name);
    }

    // If for some reason buffer_name is an illegal name, make a final fallback
    // to a workaround name. This cannot conflict with anything else, so we're
    // safe now.
    if (block_name.empty()) {
      block_name = join("_", get<SPIRType>(var.basetype).self, "_", var.self);
    }

    // Instance names cannot alias block names.
    resource_names.insert(block_name);

    bool is_patch = has_decoration(var.self, DecorationPatch);
    statement(layout_for_variable(var), (is_patch ? "patch " : ""), qual,
              block_name);
    begin_scope();

    type.member_name_cache.clear();

    uint32_t i = 0;
    for (auto& member : type.member_types) {
      add_member_name(type, i);
      emit_struct_member(type, member, i);
      i++;
    }

    add_resource_name(var.self);
    end_scope_decl(join(to_name(var.self), type_to_array_glsl(type)));
    statement("");
  } else {
    add_resource_name(var.self);
    statement(variable_decl(type, to_name(var.self), var.self), ";");
    if (output_name_.empty()) {
      output_name_ = to_name(var.self);
    }
  }
}

void CompilerSkSL::emit_function_prototype(SPIRFunction& func,
                                           const Bitset& return_flags) {
  if (func.self != ir.default_entry_point) {
    add_function_overload(func);
  }

  // Avoid shadow declarations.
  local_variable_names = resource_names;

  std::string decl;

  auto& type = get<SPIRType>(func.return_type);
  decl += flags_to_qualifiers_glsl(type, return_flags);
  decl += type_to_glsl(type);
  decl += type_to_array_glsl(type);
  decl += " ";

  if (func.self == ir.default_entry_point) {
    // SkSL requires a return value from main, so we wrap the entire entrypoint.
    // The rest of this method is copied from spirv_glsl.cpp.
    decl += "__main";
    processing_entry_point = true;
  } else {
    decl += to_name(func.self);
  }

  decl += "(";
  SmallVector<std::string> arglist;
  for (auto& arg : func.arguments) {
    // Do not pass in separate images or samplers if we're remapping
    // to combined image samplers.
    if (skip_argument(arg.id)) {
      continue;
    }

    // Might change the variable name if it already exists in this function.
    // SPIRV OpName doesn't have any semantic effect, so it's valid for an
    // implementation to use same name for variables. Since we want to make the
    // GLSL debuggable and somewhat sane, use fallback names for variables which
    // are duplicates.
    add_local_variable_name(arg.id);

    arglist.push_back(argument_decl(arg));

    // Hold a pointer to the parameter so we can invalidate the readonly field
    // if needed.
    auto* var = maybe_get<SPIRVariable>(arg.id);
    if (var) {
      var->parameter = &arg;
    }
  }

  for (auto& arg : func.shadow_arguments) {
    // Might change the variable name if it already exists in this function.
    // SPIRV OpName doesn't have any semantic effect, so it's valid for an
    // implementation to use same name for variables. Since we want to make the
    // GLSL debuggable and somewhat sane, use fallback names for variables which
    // are duplicates.
    add_local_variable_name(arg.id);

    arglist.push_back(argument_decl(arg));

    // Hold a pointer to the parameter so we can invalidate the readonly field
    // if needed.
    auto* var = maybe_get<SPIRVariable>(arg.id);
    if (var) {
      var->parameter = &arg;
    }
  }

  decl += merge(arglist);
  decl += ")";
  statement(decl);
}

std::string CompilerSkSL::type_to_glsl(const spirv_cross::SPIRType& type,
                                       uint32_t id) {
  std::string result = spirv_cross::CompilerGLSL::type_to_glsl(type, id);

  // Rewrite the type where SkSL spells it differently.

  if (type.vecsize == 1 && type.columns == 1) {  // Scalar builtins.
    switch (type.basetype) {
      case SPIRType::Boolean:
        return "bool";
      case SPIRType::SByte:
        return backend.basic_int8_type;
      case SPIRType::UByte:
        return backend.basic_uint8_type;
      case SPIRType::Short:
        return backend.basic_int16_type;
      case SPIRType::UShort:
        return backend.basic_uint16_type;
      case SPIRType::Int:
        return backend.basic_int_type;
      case SPIRType::UInt:
        return backend.basic_uint_type;
      case SPIRType::AtomicCounter:
        return "atomic_uint";
      case SPIRType::Half:
        return "half";
      case SPIRType::Float:
        return "float";
      case SPIRType::Double:
        return "float";
      case SPIRType::Int64:
        return "int";
      case SPIRType::UInt64:
        return "uint";
      case SPIRType::Void:
        return "void";
      default:
        return "???";
    }
  } else if (type.vecsize > 1 && type.columns == 1) {  // Vector builtins.
    switch (type.basetype) {
      case SPIRType::Boolean:
        return join("bool", type.vecsize);
      case SPIRType::SByte:
        return join("i8vec", type.vecsize);
      case SPIRType::UByte:
        return join("u8vec", type.vecsize);
      case SPIRType::Short:
        return join("short", type.vecsize);
      case SPIRType::UShort:
        return join("ushort", type.vecsize);
      case SPIRType::Int:
        return join("int", type.vecsize);
      case SPIRType::UInt:
        return join("uint", type.vecsize);
      case SPIRType::Half:
        return join("half", type.vecsize);
      case SPIRType::Float:
        return join("float", type.vecsize);
      case SPIRType::Double:
        return join("float", type.vecsize);
      case SPIRType::Int64:
        return join("int", type.vecsize);
      case SPIRType::UInt64:
        return join("uint", type.vecsize);
      default:
        return "???";
    }
  } else if (type.vecsize == type.columns) {  // Simple Matrix builtin
    switch (type.basetype) {
      case SPIRType::Boolean:
        return join("bool", type.vecsize, "x", type.vecsize);
      case SPIRType::Int:
        return join("int", type.vecsize, "x", type.vecsize);
      case SPIRType::UInt:
        return join("uint", type.vecsize, "x", type.vecsize);
      case SPIRType::Half:
        return join("half", type.vecsize, "x", type.vecsize);
      case SPIRType::Float:
        return join("float", type.vecsize, "x", type.vecsize);
      case SPIRType::Double:
        return join("float", type.vecsize, "x", type.vecsize);
      // Matrix types not supported for int64/uint64.
      default:
        return "???";
    }
  } else {
    switch (type.basetype) {
      case SPIRType::Boolean:
        return join("bool", type.columns, "x", type.vecsize);
      case SPIRType::Int:
        return join("int", type.columns, "x", type.vecsize);
      case SPIRType::UInt:
        return join("uint", type.columns, "x", type.vecsize);
      case SPIRType::Half:
        return join("half", type.columns, "x", type.vecsize);
      case SPIRType::Float:
        return join("float", type.columns, "x", type.vecsize);
      case SPIRType::Double:
        return join("float", type.columns, "x", type.vecsize);
      // Matrix types not supported for int64/uint64.
      default:
        return "???";
    }
  }

  return result;
}

std::string CompilerSkSL::builtin_to_glsl(spv::BuiltIn builtin,
                                          spv::StorageClass storage) {
  std::string result =
      spirv_cross::CompilerGLSL::builtin_to_glsl(builtin, storage);

  switch (builtin) {
    case BuiltInPosition:
      return "sk_Position";
    case BuiltInPointSize:
      return "sk_PointSize";
    case BuiltInVertexId:
      return "sk_VertexID";
    case BuiltInInstanceId:
      return "sk_InstanceID";
    case BuiltInVertexIndex:
      return "sk_VertexID";
    case BuiltInInstanceIndex:
      return "sk_InstanceID";
    case BuiltInFragCoord:
      return "sk_FragCoord";
    case BuiltInFrontFacing:
      return "sk_Clockwise";
    default:
      break;
  }

  return result;
}

void CompilerSkSL::emit_uniform(const spirv_cross::SPIRVariable& var) {
  spirv_cross::CompilerGLSL::add_resource_name(var.self);
  spirv_cross::CompilerGLSL::statement(
      spirv_cross::CompilerGLSL::variable_decl(var), ";");
}

}  // namespace compiler
}  // namespace impeller
