// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "impeller/compiler/spirv_sksl.h"

using namespace spv;
using namespace SPIRV_CROSS_NAMESPACE;

namespace impeller {
namespace compiler {

std::string CompilerSkSL::compile() {
  ir.fixup_reserved_names();

  // Do not deal with ES-isms like precision, older extensions and such.
  options.es = false;
  options.version = 450;
  options.vulkan_semantics = false;

  backend.allow_precision_qualifiers = false;
  backend.basic_int16_type = "short";
  backend.basic_int_type = "int";
  backend.basic_uint16_type = "ushort";
  backend.basic_uint_type = "uint";
  backend.double_literal_suffix = false;
  backend.float_literal_suffix = false;
  backend.long_long_literal_suffix = false;
  backend.needs_row_major_load_workaround = true;
  backend.nonuniform_qualifier = "";
  backend.support_precise_qualifier = false;
  backend.uint32_t_literal_suffix = false;
  backend.use_array_constructor = true;
  backend.workgroup_size_is_hidden = true;

  fixup_anonymous_struct_names();
  fixup_type_alias();
  reorder_type_alias();
  build_function_control_flow_graphs_and_analyze();
  fixup_image_load_store_access();
  update_active_builtins();
  analyze_image_and_sampler_usage();
  analyze_interlocked_resource_usage();

  uint32_t pass_count = 0;
  do {
    reset(pass_count);

    // Move constructor for this type is broken on GCC 4.9 ...
    buffer.reset();

    emit_header();
    emit_resources();

    emit_function(get<SPIRFunction>(ir.default_entry_point), Bitset());

    pass_count++;
  } while (is_forcing_recompilation());

  // TODO(zra): Rewrite main to return something.

  return buffer.str();
}

void CompilerSkSL::emit_header() {
  statement("// This SkSL shader is autogenerated by spirv-cross.");
}

void CompilerSkSL::emit_resources() {
  bool emitted = false;

  for (auto& id : ir.ids) {
    if (id.get_type() == TypeConstant) {
      auto& c = id.get<SPIRConstant>();
      bool needs_declaration = c.specialization || c.is_used_as_lut;
      if (needs_declaration) {
        if (!options.vulkan_semantics && c.specialization) {
          c.specialization_constant_macro_name = constant_value_macro_name(
              get_decoration(c.self, DecorationSpecId));
        }
        emit_constant(c);
        emitted = true;
      }
    } else if (id.get_type() == TypeConstantOp) {
      emit_specialization_constant_op(id.get<SPIRConstantOp>());
      emitted = true;
    }
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Output all basic struct types which are not Block or BufferBlock as these
  // are declared inplace when such variables are instantiated.
  for (auto& id : ir.ids) {
    if (id.get_type() == TypeType) {
      auto& type = id.get<SPIRType>();
      if (type.basetype == SPIRType::Struct && type.array.empty() &&
          !type.pointer &&
          (!ir.meta[type.self].decoration.decoration_flags.get(
               DecorationBlock) &&
           !ir.meta[type.self].decoration.decoration_flags.get(
               DecorationBufferBlock))) {
        emit_struct(type);
        emitted = true;
      }
    }
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Output UBOs and SSBOs
  for (auto& id : ir.ids) {
    if (id.get_type() == TypeVariable) {
      auto& var = id.get<SPIRVariable>();
      auto& type = get<SPIRType>(var.basetype);

      if (var.storage != StorageClassFunction && type.pointer &&
          type.storage == StorageClassUniform && !is_hidden_variable(var) &&
          (ir.meta[type.self].decoration.decoration_flags.get(
               DecorationBlock) ||
           ir.meta[type.self].decoration.decoration_flags.get(
               DecorationBufferBlock))) {
        emit_buffer_block(var);
        emitted = true;
      }
    }
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Output push constant blocks
  for (auto& id : ir.ids) {
    if (id.get_type() == TypeVariable) {
      auto& var = id.get<SPIRVariable>();
      auto& type = get<SPIRType>(var.basetype);
      if (!is_hidden_variable(var) && var.storage != StorageClassFunction &&
          type.pointer && type.storage == StorageClassPushConstant) {
        emit_push_constant_block(var);
        emitted = true;
      }
    }
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Output Uniform Constants (values, samplers, images, etc).
  for (auto& id : ir.ids) {
    if (id.get_type() == TypeVariable) {
      auto& var = id.get<SPIRVariable>();
      auto& type = get<SPIRType>(var.basetype);
      if (var.storage != StorageClassFunction && !is_hidden_variable(var) &&
          type.pointer &&
          (type.storage == StorageClassUniformConstant ||
           type.storage == StorageClassAtomicCounter)) {
        emit_uniform(var);
        emitted = true;
      }
    }
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Output in/out interfaces.
  for (auto& id : ir.ids) {
    if (id.get_type() == TypeVariable) {
      auto& var = id.get<SPIRVariable>();
      auto& type = get<SPIRType>(var.basetype);
      if (var.storage != StorageClassFunction && !is_hidden_variable(var) &&
          type.pointer &&
          (var.storage == StorageClassInput ||
           var.storage == StorageClassOutput) &&
          interface_variable_exists_in_entry_point(var.self)) {
        emit_interface_block(var);
        emitted = true;
      }
    }
  }

  if (emitted) {
    statement("");
  }
  emitted = false;

  // Global variables.
  for (auto global : global_variables) {
    auto& var = get<SPIRVariable>(global);
    if (is_hidden_variable(var, true)) {
      continue;
    }
    if (var.storage != StorageClassOutput) {
      if (!variable_is_lut(var)) {
        add_resource_name(var.self);
        std::string initializer;
        if (options.force_zero_initialized_variables &&
            var.storage == StorageClassPrivate && !var.initializer &&
            !var.static_expression &&
            type_can_zero_initialize(get_variable_data_type(var))) {
          initializer = join(" = ", to_zero_initialized_expression(
                                        get_variable_data_type_id(var)));
        }
        statement(variable_decl(var), initializer, ";");
        emitted = true;
      }
    } else if (var.initializer &&
               maybe_get<SPIRConstant>(var.initializer) != nullptr) {
      emit_output_variable_initializer(var);
    }
  }

  if (emitted) {
    statement("");
  }

  declare_undefined_values();
}

std::string CompilerSkSL::type_to_glsl(const spirv_cross::SPIRType& type,
                                       uint32_t id) {
  std::string result = spirv_cross::CompilerGLSL::type_to_glsl(type, id);

  // Rewrite the type where SkSL spells it differently.

  if (type.vecsize == 1 && type.columns == 1) {  // Scalar builtins.
    switch (type.basetype) {
      case SPIRType::Boolean:
        return "bool";
      case SPIRType::SByte:
        return backend.basic_int8_type;
      case SPIRType::UByte:
        return backend.basic_uint8_type;
      case SPIRType::Short:
        return backend.basic_int16_type;
      case SPIRType::UShort:
        return backend.basic_uint16_type;
      case SPIRType::Int:
        return backend.basic_int_type;
      case SPIRType::UInt:
        return backend.basic_uint_type;
      case SPIRType::AtomicCounter:
        return "atomic_uint";
      case SPIRType::Half:
        return "half";
      case SPIRType::Float:
        return "float";
      case SPIRType::Double:
        return "float";
      case SPIRType::Int64:
        return "int";
      case SPIRType::UInt64:
        return "uint";
      case SPIRType::Void:
        return "void";
      default:
        return "???";
    }
  } else if (type.vecsize > 1 && type.columns == 1) {  // Vector builtins.
    switch (type.basetype) {
      case SPIRType::Boolean:
        return join("bool", type.vecsize);
      case SPIRType::SByte:
        return join("i8vec", type.vecsize);
      case SPIRType::UByte:
        return join("u8vec", type.vecsize);
      case SPIRType::Short:
        return join("short", type.vecsize);
      case SPIRType::UShort:
        return join("ushort", type.vecsize);
      case SPIRType::Int:
        return join("int", type.vecsize);
      case SPIRType::UInt:
        return join("uint", type.vecsize);
      case SPIRType::Half:
        return join("half", type.vecsize);
      case SPIRType::Float:
        return join("float", type.vecsize);
      case SPIRType::Double:
        return join("float", type.vecsize);
      case SPIRType::Int64:
        return join("int", type.vecsize);
      case SPIRType::UInt64:
        return join("uint", type.vecsize);
      default:
        return "???";
    }
  } else if (type.vecsize == type.columns) {  // Simple Matrix builtin
    switch (type.basetype) {
      case SPIRType::Boolean:
        return join("bool", type.vecsize, "x", type.vecsize);
      case SPIRType::Int:
        return join("int", type.vecsize, "x", type.vecsize);
      case SPIRType::UInt:
        return join("uint", type.vecsize, "x", type.vecsize);
      case SPIRType::Half:
        return join("half", type.vecsize, "x", type.vecsize);
      case SPIRType::Float:
        return join("float", type.vecsize, "x", type.vecsize);
      case SPIRType::Double:
        return join("float", type.vecsize, "x", type.vecsize);
      // Matrix types not supported for int64/uint64.
      default:
        return "???";
    }
  } else {
    switch (type.basetype) {
      case SPIRType::Boolean:
        return join("bool", type.columns, "x", type.vecsize);
      case SPIRType::Int:
        return join("int", type.columns, "x", type.vecsize);
      case SPIRType::UInt:
        return join("uint", type.columns, "x", type.vecsize);
      case SPIRType::Half:
        return join("half", type.columns, "x", type.vecsize);
      case SPIRType::Float:
        return join("float", type.columns, "x", type.vecsize);
      case SPIRType::Double:
        return join("float", type.columns, "x", type.vecsize);
      // Matrix types not supported for int64/uint64.
      default:
        return "???";
    }
  }

  return result;
}

std::string CompilerSkSL::builtin_to_glsl(spv::BuiltIn builtin,
                                          spv::StorageClass storage) {
  std::string result =
      spirv_cross::CompilerGLSL::builtin_to_glsl(builtin, storage);

  switch (builtin) {
    case BuiltInPosition:
      return "sk_Position";
    case BuiltInPointSize:
      return "sk_PointSize";
    case BuiltInVertexId:
      return "sk_VertexID";
    case BuiltInInstanceId:
      return "sk_InstanceID";
    case BuiltInVertexIndex:
      return "sk_VertexID";
    case BuiltInInstanceIndex:
      return "sk_InstanceID";
    case BuiltInFragCoord:
      return "sk_FragCoord";
    case BuiltInFrontFacing:
      return "sk_Clockwise";
    default:
      break;
  }

  return result;
}

void CompilerSkSL::emit_uniform(const spirv_cross::SPIRVariable& var) {
  spirv_cross::CompilerGLSL::add_resource_name(var.self);
  spirv_cross::CompilerGLSL::statement(
      spirv_cross::CompilerGLSL::variable_decl(var), ";");
}

}  // namespace compiler
}  // namespace impeller
