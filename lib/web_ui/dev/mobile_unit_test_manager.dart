// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:io' as io;

import 'package:web_driver_installer/safari_driver_runner.dart';

import 'common.dart';
import 'driver_runner.dart';
import 'environment.dart';
import 'utils.dart';

/// Unit test manager for IOS Safari and Chrome on Android.
class MobileUnitTestManager {
  final String _browser;

  MobileUnitTestManager(this._browser);

  Future<void> runUnitTests() async {
    // TODO(nurhan): Add Chrome on Android.
    // https://github.com/flutter/flutter/issues/53693
    if(_browser != 'ios-safari') {
      throw Exception('Mobile unit tests are only available for ios-safari.');
    }

    final SafariDriverRunner safariDriverRunner = SafariDriverRunner();
    Future<io.Process> promise =
        safariDriverRunner.runDriver(version: 'system' /* version */);
    processesToCleanUp.add(await promise);

    // TODO(nurhan): add an option for building a single target or a set
    // of targets. The option is not available in `webdev` yet.
    await _buildTestsWebdev();
    await _serveTests();

    await UnitTestRunner().runWebDriverBasedTests(_browser);
  }

  Future<void> _buildTestsWebdev() async {
    await runProcess('webdev', ['build', '-o', 'build'],
        workingDirectory: environment.webUiRootDir.path);
  }

  Future<void> _serveTests() async {
    await startProcess('webdev', ['serve', 'test:8080'],
        workingDirectory: environment.webUiRootDir.path);
  }
}

/// Object representing the message transmission between the unit tests and the
/// test driver.
/// Inspired by: https://github.com/flutter/flutter/blob/master/packages/flutter_driver/lib/src/common/message.dart#L9
class DriverCommand {
  /// The maximum amount of time to wait for the command to complete.
  ///
  /// Defaults to no timeout, because it is common for operations to take oddly
  /// long in test environments (e.g. because the test host is overloaded), and
  /// having timeouts essentially means having race conditions.
  final Duration timeout;

  /// The message being sent from the test to the driver.
  ///
  /// For now the message is either `pass` or `fail`.
  final String message;

  /// Create a command that sends a message.
  const DriverCommand({this.message, this.timeout});

  /// Deserializes this command from the value generated by [serialize].
  DriverCommand.deserialize(Map<String, String> json)
      : this.timeout = _parseTimeout(json),
        this.message = json['message'];

  static Duration _parseTimeout(Map<String, String> json) {
    final String timeout = json['timeout'];
    if (timeout == null) return null;
    return Duration(milliseconds: int.parse(timeout));
  }

  /// Serializes this message to parameter name/value pairs.
  Map<String, String> serialize() {
    final Map<String, String> result = <String, String>{
      'command': 'fetch_test_results',
      'message': message,
    };
    if (timeout != null) {
      result['timeout'] = '${timeout.inMilliseconds}';
    }
    return result;
  }
}
