// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'package:webdriver/async_io.dart' as async_io;
import 'package:webdriver/support/async.dart';

import 'dart:async';
import 'dart:convert';

import 'package:matcher/matcher.dart';

/// Runs the unit tests using [async_io.WebDriver].
class UnitTestRunner {
  final String driverPort = '4444';

  async_io.WebDriver _testDriver;

  Future<void> runWebDriverBasedTests(String browser) async {
    assert(browser == 'ios-safari', 'Browser $browser not supported.');

    _testDriver = await _createTestDriver(
      driverPort,
      browser,
    );

    if (_testDriver == null) {
      throw Exception('Failed creating the test driver.');
    }

    // TODO(nurhan): Loop over all the tests now only one test registers the
    // driver commands to DOM. Rest will be added after the testing strategy
    // is discussed in the PR.
    await _testDriver.get(_testUrl('dom_renderer_test'));
    await _runOneTest('dom_renderer_test');

    _testDriver.quit();
  }

  String _testUrl(String testName) =>
      'http://localhost:8080/$testName.debug.html';

  Future<void> _runOneTest(String testName) async {
    Map<String, dynamic> respone = await _fetchResults(
        DriverCommand(message: 'null', timeout: Duration(seconds: 5)));
    String testResult = respone['message'] as String;
    print('run safari tests 4');
    if (testResult == 'pass') {
      print('INFO: Test passed successfully $testName');
    } else {
      // TODO(nurhan): Send a more detailed error message. We can
      // use the same method we used in e2e package.
      print('ERROR: Test failed $testName');
    }
  }

  Future<Map<String, dynamic>> _fetchResults(DriverCommand command) async {
    Map<String, dynamic> response;
    final Map<String, String> serialized = command.serialize();
    try {
      final dynamic data = await _execute(
          "window.\$feltDriver('${jsonEncode(serialized)}')", command.timeout);
      response = jsonDecode(data);
    } catch (error) {
      throw Exception(
        "Failed to respond to $command due to remote error "
        "$error\n : \$feltDriver('${jsonEncode(serialized)}')",
      );
    }
    return response['response'];
  }

  /// Sends command via WebDriver to Flutter web application
  Future<dynamic> _execute(String script, Duration duration) async {
    dynamic result;
    try {
      await _testDriver.execute(script, <void>[]);
    } catch (_) {
      // In case there is an exception, do nothing
    }

    try {
      result = await waitFor<dynamic>(
        () => _testDriver.execute(r'return $feltDriverResult', <String>[]),
        matcher: isNotNull,
        timeout: duration ?? const Duration(days: 30),
      );
    } catch (_) {
      // Returns null if exception thrown.
      return null;
    } finally {
      // Resets the result.
      await _testDriver.execute(r'''
        $feltDriverResult = null
      ''', <void>[]);
    }
    return result;
  }

  Future<async_io.WebDriver> _createTestDriver(
      String driverPort, String browser) async {
    async_io.WebDriver webDriver = await async_io.createDriver(
        uri: Uri.parse('http://localhost:$driverPort/'),
        desired: _getDesiredCapabilities(browser),
        spec: async_io.WebDriverSpec.Auto);
    return webDriver;
  }

  /// Returns desired capabilities for given [browser] and [headless].
  Map<String, dynamic> _getDesiredCapabilities(String browser) {
    if (browser == 'ios-safari') {
      return <String, dynamic>{
        'platformName': 'ios',
        'browserName': 'safari',
        'safari:useSimulator': true
      };
    } else {
      throw UnsupportedError('Browser $browser not supported.');
    }
  }
}

/// Object representing the message transmission between the unit tests and the
/// test driver.
/// Inspired by: https://github.com/flutter/flutter/blob/master/packages/flutter_driver/lib/src/common/message.dart#L9
class DriverCommand {
  /// The maximum amount of time to wait for the command to complete.
  ///
  /// Defaults to no timeout, because it is common for operations to take oddly
  /// long in test environments (e.g. because the test host is overloaded), and
  /// having timeouts essentially means having race conditions.
  final Duration timeout;

  /// The message being sent from the test to the driver.
  ///
  /// For now the message is either `pass` or `fail`.
  final String message;

  /// Create a command that sends a message.
  const DriverCommand({this.message, this.timeout});

  /// Deserializes this command from the value generated by [serialize].
  DriverCommand.deserialize(Map<String, String> json)
      : this.timeout = _parseTimeout(json),
        this.message = json['message'];

  static Duration _parseTimeout(Map<String, String> json) {
    final String timeout = json['timeout'];
    if (timeout == null) return null;
    return Duration(milliseconds: int.parse(timeout));
  }

  /// Serializes this message to parameter name/value pairs.
  Map<String, String> serialize() {
    final Map<String, String> result = <String, String>{
      'command': 'fetch_test_results',
      'message': message,
    };
    if (timeout != null) {
      result['timeout'] = '${timeout.inMilliseconds}';
    }
    return result;
  }
}
