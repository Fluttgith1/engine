// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// @dart = 2.10
part of engine;

typedef VoidCallback = void Function();
typedef ValueGetter<T> = T Function();

/// Set this flag to true to see all the fired events in the console.
const bool _debugLogKeyEvents = false;

/// After a keydown is received, this is the duration we wait for a repeat event
/// before we decide to synthesize a keyup event.
///
/// On Linux and Windows, the typical ranges for keyboard repeat delay go up to
/// 1000ms. On Mac, the range goes up to 2000ms.
const Duration _kKeydownCancelDurationNormal = Duration(milliseconds: 1000);
const Duration _kKeydownCancelDurationMacOs = Duration(milliseconds: 2000);

late final int _kCharLowerA = 'a'.codeUnitAt(0);
late final int _kCharLowerZ = 'z'.codeUnitAt(0);
late final int _kCharUpperA = 'A'.codeUnitAt(0);
late final int _kCharUpperZ = 'Z'.codeUnitAt(0);
bool isAlphabet(int charCode) {
  return (charCode >= _kCharLowerA && charCode <= _kCharLowerZ)
      || (charCode >= _kCharUpperA && charCode <= _kCharUpperZ);
}

const String _kPhysicalCapsLock = 'CapsLock';

const String _kLogicalDead = 'Dead';

const int _kWebKeyIdPlane = 0x00800000000;
const int _kAutogeneratedMask = 0x10000000000;

// Bits in a Flutter logical event to generate the logical key for dead keys.
//
// Logical keys for dead keys are generated by annotating physical keys with
// modifiers (see `_getLogicalCode`).
const int _kDeadKeyCtrl = 0x100000000000;
const int _kDeadKeyShift = 0x200000000000;
const int _kDeadKeyAlt = 0x400000000000;
const int _kDeadKeyMeta = 0x800000000000;

typedef DispatchKeyData = bool Function(ui.KeyData data);

/// Converts a floating number timestamp (in milliseconds) to a [Duration] by
/// splitting it into two integer components: milliseconds + microseconds.
Duration _eventTimeStampToDuration(num milliseconds) {
  final int ms = milliseconds.toInt();
  final int micro = ((milliseconds - ms) * Duration.microsecondsPerMillisecond).toInt();
  return Duration(milliseconds: ms, microseconds: micro);
}

class KeyboardBinding {
  /// The singleton instance of this object.
  static KeyboardBinding? get instance => _instance;
  static KeyboardBinding? _instance;

  static void initInstance(html.Element glassPaneElement) {
    if (_instance == null) {
      _instance = KeyboardBinding._(glassPaneElement);
      assert(() {
        registerHotRestartListener(_instance!._reset);
        return true;
      }());
    }
  }

  KeyboardBinding._(this.glassPaneElement) {
    _setup();
  }

  final html.Element glassPaneElement;
  late KeyboardConverter _converter;
  final Map<String, html.EventListener> _listeners = <String, html.EventListener>{};

  void _addEventListener(String eventName, html.EventListener handler) {
    final html.EventListener loggedHandler = (html.Event event) {
      if (_debugLogKeyEvents) {
        print(event.type);
      }
      if (EngineSemanticsOwner.instance.receiveGlobalEvent(event)) {
        handler(event);
      }
    };
    assert(!_listeners.containsKey(eventName));
    _listeners[eventName] = loggedHandler;
    html.window.addEventListener(eventName, loggedHandler, true);
  }

  /// Remove all active event listeners.
  void _clearListeners() {
    _listeners.forEach((String eventName, html.EventListener listener) {
      html.window.removeEventListener(eventName, listener, true);
    });
    _listeners.clear();
  }

  bool _dispatchKeyData(ui.KeyData data) {
    if (window._onKeyData != null) {
      window.invokeOnKeyData(data);
      return true;
    }
    return false;
  }

  void _setup() {
    _addEventListener('keydown', (html.Event event) {
      return _converter.handleEvent(FlutterHtmlKeyboardEvent(event as html.KeyboardEvent));
    });
    _addEventListener('keyup', (html.Event event) {
      return _converter.handleEvent(FlutterHtmlKeyboardEvent(event as html.KeyboardEvent));
    });
    _converter = KeyboardConverter(_dispatchKeyData, onMacOs: operatingSystem == OperatingSystem.macOs);
  }

  void _reset() {
    _clearListeners();
    _converter.dispose();

    _setup();
  }
}

class AsyncKeyboardDispatching {
  AsyncKeyboardDispatching({
    required this.keyData,
    this.callback,
  });

  final ui.KeyData keyData;
  final VoidCallback? callback;
}

// A wrapper of [html.KeyboardEvent] with reduced methods delegated to the event
// for the convenience of testing.
class FlutterHtmlKeyboardEvent {
  FlutterHtmlKeyboardEvent(this._event);

  final html.KeyboardEvent _event;

  String get type => _event.type;
  String? get code => _event.code;
  String? get key => _event.key;
  bool? get repeat => _event.repeat;
  num? get timeStamp => _event.timeStamp;
  bool get altKey => _event.altKey;
  bool get ctrlKey => _event.ctrlKey;
  bool get shiftKey => _event.shiftKey;
  bool get metaKey => _event.metaKey;

  bool getModifierState(String key) => _event.getModifierState(key);
  void preventDefault() => _event.preventDefault();
}

// Reads [html.KeyboardEvent], then [dispatches ui.KeyData] accordingly.
//
// The events are read through [handleEvent], and dispatched through the
// [dispatchKeyData] as given in the constructor. Some key data might be
// dispatched asynchronously.
class KeyboardConverter {
  KeyboardConverter(this.dispatchKeyData, {this.onMacOs = false});

  final DispatchKeyData dispatchKeyData;
  final bool onMacOs;

  bool _disposed = false;
  void dispose() {
    _disposed = true;
  }

  // On macOS, CapsLock behaves differently in that, a keydown event occurs when
  // the key is pressed and the light turns on, while a keyup event occurs when the
  // key is pressed and the light turns off. Flutter considers both events as
  // key down, and synthesizes immediate cancel events following them. The state
  // of "whether CapsLock is on" should be accessed by "lockFlags".
  bool _shouldSynthesizeCapsLockCancel() {
    return onMacOs;
  }

  Duration get _keydownCancelDuration => onMacOs ? _kKeydownCancelDurationMacOs : _kKeydownCancelDurationNormal;

  bool _shouldPreventDefault(FlutterHtmlKeyboardEvent event) {
    switch (event.key) {
      case 'Tab':
        return true;

      default:
        return false;
    }
  }

  static int _getPhysicalCode(String code) {
    return kWebToPhysicalKey[code] ?? (code.hashCode + _kWebKeyIdPlane + _kAutogeneratedMask);
  }

  static int _getModifierMask(FlutterHtmlKeyboardEvent event) {
    final bool altDown = event.altKey;
    final bool ctrlDown = event.ctrlKey;
    final bool shiftDown = event.shiftKey;
    final bool metaDown = event.metaKey;
    return (altDown ? _kDeadKeyAlt : 0) +
           (ctrlDown ? _kDeadKeyCtrl : 0) +
           (shiftDown ? _kDeadKeyShift : 0) +
           (metaDown ? _kDeadKeyMeta : 0);
  }

  // Whether `event.key` should be considered a key name.
  //
  // The `event.key` can either be a key name or the printable character. If the
  // first character is an alphabet, it must be either 'A' to 'Z' ( and return
  // true), or be a key name (and return false). Otherwise, return true.
  static bool _eventKeyIsKeyname(String key) {
    assert(key.length > 0);
    return isAlphabet(key.codeUnitAt(0)) && key.length > 1;
  }

  static int _characterToLogicalKey(String key) {
    // Assume the length being <= 2 to be sufficient in all cases. If not,
    // extend the algorithm.
    assert(key.length <= 2);
    int result = key.codeUnitAt(0) & 0xffff;
    if (key.length == 2) {
      result += key.codeUnitAt(1) << 16;
    }
    return result;
  }

  static int _deadKeyToLogicalKey(int physicalKey, FlutterHtmlKeyboardEvent event) {
    // 'Dead' is used to represent dead keys, such as a diacritic to the
    // following base letter (such as Option-e results in Â´).
    //
    // Assume they can be told apart with the physical key and the modifiers
    // pressed.
    return physicalKey + _getModifierMask(event) + _kWebKeyIdPlane + _kAutogeneratedMask;
  }

  static int _otherLogicalKey(String key) {
    return kWebToLogicalKey[key] ?? (key.hashCode + _kWebKeyIdPlane + _kAutogeneratedMask);
  }

  // Map from pressed physical key to corresponding pressed logical key.
  //
  // Multiple physical keys can be mapped to the same logical key, usually due
  // to positioned keys (left/right/numpad) or multiple keyboards.
  final Map<int, int> _pressingRecords = <int, int>{};

  // Return the pressing state of modifier keys extracted from event flags
  // (ctrlKey, shiftKey, etc.).
  bool? _logicalModifierStateByFlag(String key, FlutterHtmlKeyboardEvent event) {
    switch(key) {
      case 'Shift':
        return event.shiftKey;
      case 'Control':
        return event.ctrlKey;
      case 'Meta':
        return event.metaKey;
      case 'Meta':
        return event.metaKey;
      case 'Alt':
        return event.altKey;
    }
    return null;
  }

  // Schedule the dispatching of an event in the future. The `callback` will
  // invoked before that.
  //
  // Returns a callback that cancels the schedule. Disposal of
  // `KeyBoardConverter` also cancels the shedule automatically.
  VoidCallback _scheduleAsyncEvent(Duration duration, ValueGetter<ui.KeyData> getData, VoidCallback callback) {
    bool canceled = false;
    Future<void>.delayed(duration).then<void>((_) {
      if (!canceled && !_disposed) {
        callback();
        dispatchKeyData(getData());
      }
    });
    return () { canceled = true; };
  }

  // ## About Key guards
  //
  // When the user enters a browser/system shortcut (e.g. `cmd+alt+i`) the
  // browser doesn't send a keyup for it. This puts the framework in a corrupt
  // state because it thinks the key was never released.
  //
  // To avoid this, we rely on the fact that browsers send repeat events
  // while the key is held down by the user. If we don't receive a repeat
  // event within a specific duration ([_keydownCancelDuration]) we assume
  // the user has released the key and we synthesize a keyup event.
  final Map<int, VoidCallback> _keyGuards = <int, VoidCallback>{};
  // Call this method on the down or repeated event of a non-modifier key.
  void _startGuardingKey(int physicalKey, int logicalKey, Duration currentTimeStamp) {
    final VoidCallback cancelingCallback = _scheduleAsyncEvent(
      _keydownCancelDuration,
      () => ui.KeyData(
        timeStamp: currentTimeStamp + _keydownCancelDuration,
        change: ui.KeyChange.cancel,
        key: physicalKey,
        lockFlags: 0,
        logicalEvents: <ui.LogicalKeyData>[
          ui.LogicalKeyData(
            change: ui.KeyChange.cancel,
            key: logicalKey,
          ),
        ],
      ),
      () {
        _pressingRecords.remove(physicalKey);
      }
    );
    _keyGuards.remove(physicalKey)?.call();
    _keyGuards[physicalKey] = cancelingCallback;
  }
  // Call this method on an up event event of a non-modifier key.
  void _stopGuardingKey(int physicalKey) {
    _keyGuards.remove(physicalKey)?.call();
  }

  bool handleEvent(FlutterHtmlKeyboardEvent event) {
    final List<ui.LogicalKeyData> logicalKeyDataList = <ui.LogicalKeyData>[];

    if (_shouldPreventDefault(event)) {
      event.preventDefault();
    }
    final String eventKey = event.key!;

    final int physicalKey = _getPhysicalCode(event.code!);
    final bool logicalKeyIsCharacter = !_eventKeyIsKeyname(eventKey);
    final int logicalKey = logicalKeyIsCharacter ? _characterToLogicalKey(eventKey)
        : eventKey == _kLogicalDead ? _deadKeyToLogicalKey(physicalKey, event)
        : _otherLogicalKey(eventKey);
    final Duration timeStamp = _eventTimeStampToDuration(event.timeStamp!);
    final String? character = logicalKeyIsCharacter ? eventKey : null;

    assert(event.type == 'keydown' || event.type == 'keyup');
    final bool isPhysicalDown = event.type == 'keydown' ||
      // On macOS, both keydown and keyup events of CapsLock should be considered keydown,
      // followed by an immediate cancel event.
      (_shouldSynthesizeCapsLockCancel() && event.code! == _kPhysicalCapsLock);

    // The value of _pressingRecords[physicalKey] before and after calculating the events.
    // See `_pressingRecords` for its meaning.
    final int? lastLogicalRecord = _pressingRecords[physicalKey];
    final int? nextLogicalRecord = isPhysicalDown ? logicalKey : null;

    // Possible synthesized key event to synchronize states before the main event.
    ui.KeyData? preSynthesizedKeyData;

    if (lastLogicalRecord != nextLogicalRecord) {
      // Case 1: The pressing record for the physical key becomes a different
      // record from before.
      //
      //  * From null to non-null: Simple keydown
      //  * From non-null to null: Simple keyup
      //  * From non-null to a different non-null: The physical key starts to map
      //    to a different logical key. Cancel the previous one and sync the new one.

      // First remove the physical key to see if the logical key is still pressed after that.
      _pressingRecords.remove(physicalKey);
      if (lastLogicalRecord != null && !_pressingRecords.containsValue(lastLogicalRecord)) {
        logicalKeyDataList.add(ui.LogicalKeyData(
          change: nextLogicalRecord == null ? ui.KeyChange.up : ui.KeyChange.cancel,
          key: lastLogicalRecord,
        ));
      }
      if (nextLogicalRecord != null && !_pressingRecords.containsValue(nextLogicalRecord)) {
        logicalKeyDataList.add(ui.LogicalKeyData(
          change: lastLogicalRecord == null ? ui.KeyChange.down : ui.KeyChange.synchronize,
          key: nextLogicalRecord,
          character: character,
        ));
      }

      // On macOS, both keydown and keyup events of CapsLock are considered
      // keydown, followed by an immediate cancel event.
      if (event.code! == _kPhysicalCapsLock && _shouldSynthesizeCapsLockCancel()) {
        _scheduleAsyncEvent(
          Duration.zero,
          () => ui.KeyData(
            timeStamp: timeStamp,
            change: ui.KeyChange.cancel,
            key: physicalKey,
            lockFlags: 0,
            logicalEvents: <ui.LogicalKeyData>[
              ui.LogicalKeyData(
                change: ui.KeyChange.cancel,
                key: logicalKey,
              ),
            ],
          ),
          () {
            _pressingRecords.remove(physicalKey);
          }
        );
      }

    } else if (nextLogicalRecord != null) {
      // Case 2: The pressing record for the physical key is a same non-null
      // record as before, but received an event anyway.
      //
      //  * Repeated: A normal repeated event
      //  * Non-repeated: Indicates an up event has been omitted
      assert(isPhysicalDown);

      if (event.repeat ?? false) {
        logicalKeyDataList.add(ui.LogicalKeyData(
          change: ui.KeyChange.repeatedDown,
          key: nextLogicalRecord,
          character: character,
        ));
      } else {
        // This happens when the up event was omitted, usually due to loss of
        // focus or shortcuts. A physical cancel must be synthesized, otherwise
        // the physical press can not be represented.
        preSynthesizedKeyData = ui.KeyData(
          timeStamp: timeStamp,
          change: ui.KeyChange.cancel,
          key: physicalKey,
          lockFlags: 0,
          logicalEvents: <ui.LogicalKeyData>[
            ui.LogicalKeyData(
              change: ui.KeyChange.cancel,
              key: nextLogicalRecord,
            ),
          ],
        );

        logicalKeyDataList.add(ui.LogicalKeyData(
          change: ui.KeyChange.down,
          key: nextLogicalRecord,
          character: character,
        ));
      }
    } else {
      // Case 3: The physical record for the physical key is a same null state
      // as before, indicating an omitted down event, usually due to loss of
      // focus. Skip.
      return false;
    }

    // Update _pressingRecords. It might have been updated before if necessary,
    // but the update is done here anywaay.
    if (nextLogicalRecord == null) {
      _pressingRecords.remove(physicalKey);
    } else {
      _pressingRecords[physicalKey] = nextLogicalRecord;
    }

    final ui.KeyData keyData = ui.KeyData(
      timeStamp: timeStamp,
      change: isPhysicalDown
        ? (event.repeat ?? false ? ui.KeyChange.repeatedDown : ui.KeyChange.down)
        : ui.KeyChange.up,
      key: physicalKey,
      lockFlags: 0,
      logicalEvents: logicalKeyDataList,
    );

    if (logicalKeyIsCharacter) {
      if (keyData.change == ui.KeyChange.down || keyData.change == ui.KeyChange.repeatedDown) {
        _startGuardingKey(physicalKey, logicalKey, timeStamp);
      } else if (keyData.change == ui.KeyChange.up) {
        _stopGuardingKey(physicalKey);
      }
    }

    if (preSynthesizedKeyData != null) {
      dispatchKeyData(preSynthesizedKeyData);
    }
    return dispatchKeyData(keyData);
  }
}
