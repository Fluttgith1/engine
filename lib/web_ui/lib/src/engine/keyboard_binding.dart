// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// @dart = 2.10
part of engine;

/// Set this flag to true to see all the fired events in the console.
const bool _debugLogKeyEvents = false;

late final int kCharLowerA = 'a'.codeUnitAt(0);
late final int kCharLowerZ = 'z'.codeUnitAt(0);
late final int kCharUpperA = 'A'.codeUnitAt(0);
late final int kCharUpperZ = 'Z'.codeUnitAt(0);
bool isAlphabet(int charCode) {
  return (charCode >= kCharLowerA && charCode <= kCharLowerZ)
      || (charCode >= kCharUpperA && charCode <= kCharUpperZ);
}

const int kWebKeyIdPlane = 0x00800000000;
const int kAutogeneratedMask = 0x10000000000;

// Bits reserved to annotate logical modifiers to physical keys to generate
// codes for dead keys (see `_getLogicalCode`).
//
// Also used to as modifier state to store and to compare.
const int kDeadKeyModifierMask = 0xf00000000000;
const int kDeadKeyCtrl = 0x100000000000;
const int kDeadKeyShift = 0x200000000000;
const int kDeadKeyAlt = 0x400000000000;
const int kDeadKeyMeta = 0x800000000000;

typedef DispatchKeyData = bool Function(ui.KeyData data);

/// Converts a floating number timestamp (in milliseconds) to a [Duration] by
/// splitting it into two integer components: milliseconds + microseconds.
Duration _eventTimeStampToDuration(num milliseconds) {
  final int ms = milliseconds.toInt();
  final int micro = ((milliseconds - ms) * Duration.microsecondsPerMillisecond).toInt();
  return Duration(milliseconds: ms, microseconds: micro);
}

class KeyboardBinding {
  /// The singleton instance of this object.
  static KeyboardBinding? get instance => _instance;
  static KeyboardBinding? _instance;

  static void initInstance(html.Element glassPaneElement) {
    if (_instance == null) {
      _instance = KeyboardBinding._(glassPaneElement);
      assert(() {
        registerHotRestartListener(_instance!._reset);
        return true;
      }());
    }
  }

  KeyboardBinding._(this.glassPaneElement) {
    _setup();
  }

  final html.Element glassPaneElement;
  late _KeyboardConverter _converter;
  final Map<String, html.EventListener> _listeners = <String, html.EventListener>{};

  void _addEventListener(String eventName, html.EventListener handler) {
    final html.EventListener loggedHandler = (html.Event event) {
      if (_debugLogKeyEvents) {
        print(event.type);
      }
      if (EngineSemanticsOwner.instance.receiveGlobalEvent(event)) {
        handler(event);
      }
    };
    assert(!_listeners.containsKey(eventName));
    _listeners[eventName] = loggedHandler;
    html.window.addEventListener(eventName, loggedHandler, true);
  }

  /// Remove all active event listeners.
  void _clearListeners() {
    _listeners.forEach((String eventName, html.EventListener listener) {
      html.window.removeEventListener(eventName, listener, true);
    });
    _listeners.clear();
  }

  bool _dispatchKeyData(ui.KeyData data) {
    if (window._onKeyData != null) {
      window.invokeOnKeyData(data);
      return true;
    }
    return false;
  }

  void _setup() {
    _addEventListener('keydown', (html.Event event) {
      return _converter.handleEvent(event as html.KeyboardEvent);
    });
    _addEventListener('keyup', (html.Event event) {
      return _converter.handleEvent(event as html.KeyboardEvent);
    });
    _converter = _KeyboardConverter(_dispatchKeyData);
  }

  void _reset() {
    _clearListeners();
    _converter.dispose();

    _setup();
  }
}

class _KeyboardConverter {
  _KeyboardConverter(this.dispatchKeyData);

  final DispatchKeyData dispatchKeyData;

  void dispose() {
  }

  bool _shouldPreventDefault(html.KeyboardEvent event) {
    switch (event.key) {
      case 'Tab':
        return true;

      default:
        return false;
    }
  }

  static int _getPhysicalCode(String code) {
    return kWebToPhysicalKey[code] ?? (code.hashCode + kWebKeyIdPlane + kAutogeneratedMask);
  }

  static int _getModifierMask(html.KeyboardEvent event) {
    final bool altDown = event.altKey;
    final bool ctrlDown = event.ctrlKey;
    final bool shiftDown = event.shiftKey;
    // "Win" key might not be considered meta in some cases; "OS" covers the
    // other cases. See
    // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState
    final bool metaDown = event.metaKey || event.getModifierState("OS");
    return (altDown ? kDeadKeyAlt : 0) |
           (ctrlDown ? kDeadKeyCtrl : 0) |
           (shiftDown ? kDeadKeyShift : 0) |
           (metaDown ? kDeadKeyMeta : 0);
  }

  // Whether `event.key` should be considered a key name.
  //
  // The `event.key` can either be a key name or the printable character. If the
  // first character is an alphabet, it must be either 'A' to 'Z' ( and return
  // true), or be a key name (and return false). Otherwise, return true.
  static bool _eventKeyIsKeyname(String key) {
    assert(key.length > 0);
    return isAlphabet(key.codeUnitAt(0)) && key.length > 1;
  }

  static int _characterToLogicalKey(String key) {
    // Assume the length being <= 2 to be sufficient in all cases. If not,
    // extend the algorithm.
    assert(key.length <= 2);
    int result = key.codeUnitAt(0) & 0xffff;
    if (key.length == 2) {
      result += key.codeUnitAt(1) << 16;
    }
    return result;
  }

  static int _deadKeyToLogicalKey(int physicalKey, html.KeyboardEvent event) {
    // 'Dead' is used to represent dead keys, such as a diacritic to the
    // following base letter (such as Option-e results in Â´).
    //
    // Assume they can be told apart with the physical key and the modifiers
    // pressed.
    return physicalKey + _getModifierMask(event) + kWebKeyIdPlane + kAutogeneratedMask;
  }

  static int _otherLogicalKey(String key) {
    return kWebToLogicalKey[key] ?? (key.hashCode + kWebKeyIdPlane + kAutogeneratedMask);
  }

  // Map from pressed physical key to corresponding pressed logical key
  final Map<int, int> _pressedKeys = <int, int>{};

  // Return the pressing state of modifier keys extracted from event flags
  // (ctrlKey, shiftKey, etc.).
  bool? _logicalModifierStateByFlag(String key, html.KeyboardEvent event) {
    switch(key) {
      case 'Shift':
        return event.shiftKey;
      case 'Control':
        return event.ctrlKey;
      case 'Meta':
        return event.metaKey;
      case 'Meta':
        return event.metaKey;
      case 'Alt':
        return event.altKey;
    }
    return null;
  }

  bool handleEvent(html.KeyboardEvent event) {
    final List<ui.LogicalKeyData> logicalKeyDataList = <ui.LogicalKeyData>[];

    if (_shouldPreventDefault(event)) {
      event.preventDefault();
    }
    final String eventKey = event.key!;

    final int physicalKey = _getPhysicalCode(event.code!);
    final bool logicalKeyIsCharacter = !_eventKeyIsKeyname(eventKey);
    final int logicalKey = logicalKeyIsCharacter ? _characterToLogicalKey(eventKey)
        : eventKey == 'Dead' ? _deadKeyToLogicalKey(physicalKey, event)
        : _otherLogicalKey(eventKey);
    final Duration timeStamp = _eventTimeStampToDuration(event.timeStamp!);
    final String? character = logicalKeyIsCharacter ? eventKey : null;

    final bool isPhysicalDown = event.type == 'keydown';
    assert(isPhysicalDown || event.type == 'keyup');

    // final bool? trueLogicalPressingState = _logicalModifierStateByFlag(eventKey, event);
    final int? nextLogicalKey = isPhysicalDown ? logicalKey : null;
    final int? lastLogicalKey = _pressedKeys[physicalKey];

    if (lastLogicalKey != nextLogicalKey) {
      if (lastLogicalKey != null) {
        logicalKeyDataList.add(ui.LogicalKeyData(
          change: nextLogicalKey == null ? ui.KeyChange.up : ui.KeyChange.cancel,
          key: lastLogicalKey,
        ));
      }
      if (nextLogicalKey != null) {
        logicalKeyDataList.add(ui.LogicalKeyData(
          change: lastLogicalKey == null ? ui.KeyChange.down : ui.KeyChange.synchronize,
          key: nextLogicalKey,
          character: character,
        ));
      }
    } else {
      if (event.repeat ?? false) {
        assert(nextLogicalKey != null);
        logicalKeyDataList.add(ui.LogicalKeyData(
          change: ui.KeyChange.repeatedDown,
          key: nextLogicalKey!,
          character: character,
        ));
      } else {
        // The same key from being pressed to being pressed. Skip.
        return false;
      }
    }
    if (nextLogicalKey == null) {
      _pressedKeys.remove(physicalKey);
    } else {
      _pressedKeys[physicalKey] = nextLogicalKey;
    }

    final ui.KeyData keyData = ui.KeyData(
      timeStamp: timeStamp,
      change: isPhysicalDown
        ? (event.repeat ?? false ? ui.KeyChange.repeatedDown : ui.KeyChange.down)
        : ui.KeyChange.up,
      key: physicalKey,
      lockFlags: 0,
      logicalEvents: logicalKeyDataList,
    );

    return dispatchKeyData(keyData);
  }
}
